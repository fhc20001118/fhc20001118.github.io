<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿川的博客</title>
  
  <subtitle>学习</subtitle>
  <link href="http://fhc20001118.github.io/project/atom.xml" rel="self"/>
  
  <link href="http://fhc20001118.github.io/project/"/>
  <updated>2023-04-21T10:02:52.216Z</updated>
  <id>http://fhc20001118.github.io/project/</id>
  
  <author>
    <name>阿川</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webserver开发</title>
    <link href="http://fhc20001118.github.io/project/2023/04/20/webserver%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>http://fhc20001118.github.io/project/2023/04/20/webserver%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%80%E7%AB%A0/</id>
    <published>2023-04-19T16:00:00.000Z</published>
    <updated>2023-04-21T10:02:52.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注册信号捕捉时，struct-sigaction在vscode中报错（但是编译通过，运行也没有问题），查找大量资料发现原来是c编译器的标准问题，改为gnu17就不会报错了"><a href="#注册信号捕捉时，struct-sigaction在vscode中报错（但是编译通过，运行也没有问题），查找大量资料发现原来是c编译器的标准问题，改为gnu17就不会报错了" class="headerlink" title="注册信号捕捉时，struct sigaction在vscode中报错（但是编译通过，运行也没有问题），查找大量资料发现原来是c编译器的标准问题，改为gnu17就不会报错了"></a>注册信号捕捉时，struct sigaction在vscode中报错（但是编译通过，运行也没有问题），查找大量资料发现原来是c编译器的标准问题，改为gnu17就不会报错了</h1><h1 id="perror"><a href="#perror" class="headerlink" title="perror"></a>perror</h1><p>perror ( )用 来 将 上 一 个 函 数 发 生 错 误 的 原 因 输 出 到 标 准 设备 (stderr) 。参数 s 所指的字符串会先打印出,后面再加上错误原因字符串。此错误原因依照全局变量errno 的值来决定要输出的字符串。 　　在库函数中有个errno变量，每个errno值对应着以字符串表示的错误类型。当你调用”某些”函数出错时，该函数已经重新设置了errno的值。perror函数只是将你输入的一些信息和现在的errno所对应的错误一起输出。</p><h1 id="rm-无法删除’lesson4-‘-是一个目录-解决办法"><a href="#rm-无法删除’lesson4-‘-是一个目录-解决办法" class="headerlink" title="rm: 无法删除’lesson4/‘: 是一个目录 解决办法"></a>rm: 无法删除’lesson4/‘: 是一个目录 解决办法</h1><pre class="line-numbers language-none"><code class="language-none">rm -r lesson4&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-r是递归地删除子目录</p><h1 id="xftp链接Linux打开后中文文件乱码"><a href="#xftp链接Linux打开后中文文件乱码" class="headerlink" title="xftp链接Linux打开后中文文件乱码"></a>xftp链接Linux打开后中文文件乱码</h1><p>在属性中点击选项，把编码改为utf-8</p><p><img src="https://img-blog.csdnimg.cn/20190308142331435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dfcmNzcw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="vscode下载了插件remote-development没有出现ssh-targets选项"><a href="#vscode下载了插件remote-development没有出现ssh-targets选项" class="headerlink" title="vscode下载了插件remote-development没有出现ssh-targets选项"></a>vscode下载了插件remote-development没有出现ssh-targets选项</h1><p>选择远程，里面有个ssh</p><h1 id="使用vscode连接远程Linux服务器时，用c-c-无法编译，显示头文件打不开。"><a href="#使用vscode连接远程Linux服务器时，用c-c-无法编译，显示头文件打不开。" class="headerlink" title="使用vscode连接远程Linux服务器时，用c/c++无法编译，显示头文件打不开。"></a>使用vscode连接远程Linux服务器时，用c/c++无法编译，显示头文件打不开。</h1><p>在Ubuntu系统中的终端下载gcc编译器 sudo apt install gcc</p><h1 id="避免每次登陆都要密码"><a href="#避免每次登陆都要密码" class="headerlink" title="避免每次登陆都要密码"></a>避免每次登陆都要密码</h1><p>生成本机的公钥ssh-keygen -t  rsa</p><p>把本机的公钥id_rsa.pub发送给虚拟机</p><p>用xshell连接linux，生成密钥ssh-keygen -t rsa</p><p>创建一个固定文件 vim authorized-keys,把Windows的公钥复制进去，保存并退出(按esc进入命令模式，:q退出不保存，:wq保存并退出)</p><h1 id="linux删除文件命令rm-f-文件名"><a href="#linux删除文件命令rm-f-文件名" class="headerlink" title="linux删除文件命令rm -f 文件名"></a>linux删除文件命令rm -f 文件名</h1><h1 id="在终端中创建代码文件-在vscode中编写"><a href="#在终端中创建代码文件-在vscode中编写" class="headerlink" title="在终端中创建代码文件,在vscode中编写"></a>在终端中创建代码文件,在vscode中编写</h1><p>touch test.c</p><h1 id="如何在终端编译文件-记得vscode编写完代码要保存！！！"><a href="#如何在终端编译文件-记得vscode编写完代码要保存！！！" class="headerlink" title="如何在终端编译文件(记得vscode编写完代码要保存！！！)"></a>如何在终端编译文件(记得vscode编写完代码要保存！！！)</h1><p>gcc test.c -o app    -o是生产目标文件</p><p>gcc test.c直接生成a.out</p><h1 id="终端执行文件输出结果"><a href="#终端执行文件输出结果" class="headerlink" title="终端执行文件输出结果"></a>终端执行文件输出结果</h1><p>./app</p><h1 id="gcc工作流程"><a href="#gcc工作流程" class="headerlink" title="gcc工作流程"></a>gcc工作流程</h1><p>源代码（.h .c .cpp)经过预处理器变为预处理后源代码</p><p>再经过编译器变为汇编代码</p><p>再经过汇编器变成目标代码</p><p>再经过链接器变成可执行程序</p><p>-E 预处理 （把宏替换，删掉注释）</p><p>-S 编译 （把代码变成汇编代码）</p><p>-s 对代码进行汇编，生成可执行文件</p><p>-c 链接 （链接程序) 生成.o文件</p><p>g++也能编译c程序</p><p>-I(大写i) directory 指定include包含文件的搜索目录</p><p>-g 在编译的时候生成调试信息，该程序可以被调试器调试</p><p>-D 在程序编译的时候指定一个宏</p><p>-w 不生成任何警告</p><p>-Wall 生成所有警告</p><p>-On n的取值范围0-3。编译器的优化选项的4个级别，-O0表示没有优化，-O1为默认，-O3优化级别最高</p><p>-l(小写L) 在程序编译的时候指定使用的库 （libxxx 指定的是xxx）</p><p>-L 指定编译的时候，搜索库的路径</p><p>-fpic/-fPIC 生成与位置无关的代码</p><p>-shared 生成共享目标文件，通常用在建立共享库时</p><p>-std 指定c方言，如：-std=c99 ，gcc默认方言是GNU C</p><h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><p>1、.c文件 gcc当成c程序，g++当成c++程序</p><p>.cpp文件 gcc和g++都当成c++程序</p><p>但是gcc不能自动和c++库连接，所以统一用g++编译</p><p>2、__cplusplus宏标志着编译器会把代码按c还是c++语法来解释</p><p>如果后缀为.c 并且采用gcc编译器，则该宏未定义，否则已定义</p><p>3、在编译阶段，g++会调用gcc</p><p>连接使用g++或者 gcc -lstdc++</p><h1 id="库文件"><a href="#库文件" class="headerlink" title="库文件"></a>库文件</h1><p>1、库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，他给使用者提供一些可以直接使用的变量、函数或类。</p><p>2、库是特殊的一种程序，编写库的程序与一般编写的程序区别不大，只是库不能单独运行</p><p>3、库文件有两种：静态库和动态库</p><p>静态库：在程序的链接阶段被复制到了程序中</p><p>动态库：程序在运行时由系统动态加载到内存中供程序使用</p><p>4、库的好处：代码保密；方便部署和分发</p><h1 id="静态库的制作"><a href="#静态库的制作" class="headerlink" title="静态库的制作"></a>静态库的制作</h1><p>1、命名规则</p><ul><li><p>Linux：libxxx.a</p><p>lib：前缀（固定）    library</p><p>xxx：库的名字（自己取）</p><p>.a：后缀（固定）</p></li><li><p>Windows：libxxx.lib</p></li></ul><p>2、静态库的制作</p><ul><li>gcc获得.o文件</li><li>将.o文件打包，使用ar工具（archive）</li></ul><pre class="line-numbers language-none"><code class="language-none">ar rcs libxxx.a xxx.o xxx.o <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    r    将文件插入备存文件中</p><p>​    c    建立备存文件</p><p>​    s    索引</p><p>3、优点：</p><ul><li>静态库被打包到应用程序中加载速度极快</li><li>发布程序无需提供静态库，移植方便</li></ul><p>4、缺点：</p><ul><li>消耗系统资源，浪费内存</li><li>更新、部署、发布麻烦（如果程序代码修改需要重新编译）</li></ul><h1 id="动态库的制作"><a href="#动态库的制作" class="headerlink" title="动态库的制作"></a>动态库的制作</h1><p>1、命名规则</p><ul><li><p>Linux：libxxx.so</p><p>lib：前缀（固定）</p><p>xxx：库的名字，自己起</p><p>.so：后缀（固定）</p><p>在linux下是一个可执行文件</p></li><li><p>Windows：libxxx.dll</p></li></ul><p>2、动态库的制作</p><ul><li>gcc得到.o文件，得到和位置无关的代码</li></ul><pre class="line-numbers language-none"><code class="language-none">gcc -c -fpic&#x2F;-fPIC a.c b.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>gcc得到动态库</li></ul><pre class="line-numbers language-none"><code class="language-none">gcc -shared a.o b.o -o libxxx.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、优点：</p><ul><li>可以实现进程间资源共享（共享库）</li><li>更新、部署、发布简单</li><li>可以控制何时加载动态库</li></ul><p>4、缺点：</p><ul><li>加载速度比静态慢</li><li>发布程序时需要提供依赖的动态库</li></ul><h1 id="静-动态库的工作原理"><a href="#静-动态库的工作原理" class="headerlink" title="静/动态库的工作原理"></a>静/动态库的工作原理</h1><ul><li><p>静态库：GCC进行链接时，会把静态库中的代码打包到可执行程序中</p></li><li><p>动态库：GCC进行链接时，不会把动态库中的代码打包到可执行程序中</p></li><li><p>程序启动之后，动态库会被动态加载到内存中，通过ldd（list dynamic dependencies）命令检查动态库依赖关系</p></li><li><p>如何定位共享库文件？</p><p>当系统加载可执行文件代码时候，能够知道其所依赖库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径。对于elf格式的可执行程序，是由ld-linux.so来完成的，它先后搜索elf文件的DT_RPATH段    ——&gt; 环境变量    ——&gt; LD_LIBRARY_PATH    ——&gt; /etc/ld.so.cache文件列表    ——&gt; /lib/, /usr/lib （不建议，因为可能会覆盖其他同名的库）目录找到库文件后将其载入内存。</p></li></ul><h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><p>1、什么是Makefile：</p><ul><li>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为Makefile文件就像一个shell脚本一样，也可以执行操作系统的命令</li><li>Makefile带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释Makefile文件中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如Delphi的make，Visual c++的nmake，Linux下GNU的make。</li></ul><p>2、Makefile文件命名和规则：</p><ul><li><p>文件命名：</p><p>makefile或者Makefile</p></li><li><p>Makefile规则：</p><p>一个Makefile文件可以有一个或者多个规则</p><pre class="line-numbers language-none"><code class="language-none">目标...: 依赖 ...命令（shell命令）...目标：最终要生成的文件（伪目标除外）依赖：生产目标所需要的文件或是目标命令：通过执行命令对依赖操作生产目标（命令前必须tab缩进）app: add.c main.c sub.c mult.c div.cgcc add.c main.c sub.c mult.c div.c -o app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Makefile中的其他规则一般都是为第一条规则服务的</p></li></ul><p>3、工作原理</p><ul><li><p>命令在执行前，需要先检查规则中的依赖是否存在</p><p>如果存在，执行命令</p><p>如果不存在，向下检查其他规则，检查有没有一个规则是用来生成这个依赖的，如果找到了，则执行该规则中的命令</p></li><li><p>检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间</p><p>如果依赖的时间比目标的时间晚，需要重新生成目标(说明依赖被更改过，需要重新生成目标)</p><p>如果依赖的时间比目标时间早，目标不需要更新，对应规则中的命令不需要被执行</p></li></ul><p>4、变量</p><ul><li><p>自定义变量：</p><p>变量名 = 变量值    var = hello</p></li><li><p>预定义变量</p><p>AR：归档维护程序的名称，默认值为ar</p><p>CC：C编译器的名称，默认值为cc</p><p>CXX：C++编译器的名称，默认值为g++</p><p>$@：目标的完整名称</p><p>$&lt;：第一个依赖文件的名称</p><p>$^：所有的依赖文件</p></li><li><p>获取变量的值</p><p>$(变量名)</p><pre class="line-numbers language-none"><code class="language-none">app:main.c a.c b.c$(CC) -c $^ -o $@相当于gcc -c main.c a.c b.c -o app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>5、模式匹配</p><p>如果有100个c文件，就要定义100个规则，相当麻烦</p><pre class="line-numbers language-none"><code class="language-none">add.o:add.cgcc -c add.cdiv.o:div.cgcc -c div.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>采用模式匹配的方法</p><pre class="line-numbers language-none"><code class="language-none">%.o:%.cgcc -c $&lt; -o $@<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>6、函数</p><ul><li><p>$(wildcard PATTERN…)</p><p>功能：获取指定目录下指定类型的文件列表</p><p>参数：PATTERN指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔</p><p>返回：得到的若干个文件的文件列表，文件名之间使用空格间隔</p><p>示例：</p><p>​    $(wildcard    <em>.c    ./sub/</em>.c)</p><p>​    返回值格式：a.c b.c c.c d.c e.c f.c </p></li><li><p>$(patsubst <pattern>, <replacement>,<text>)</p><p>功能：查找text中的单词（单词以空格、Tab或回车、换行分割）是否符合模式pattern，如果匹配的话，则以replacement替换</p><p>pattern可以包括通配符%，表示任意长度的字串。如果replacement中也包含%，那么，replacement中的这个%将是pattern中的那个%所代表的字串（%表示的是字符%）</p><p>返回：函数返回被替换过后的字符串</p><p>示例：</p><p>​    $(patsubst %.c, %.o, x.c bar.c)</p><p>​    返回值格式：x.o bar.o </p><p>注意：我们可以定义clean目标来删除文件（依赖为空）</p><pre class="line-numbers language-none"><code class="language-none">clean:rm $(objs) -f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但如果我们创造了一个clean文件，执行make clean将会显示clean已是最新，这是因为依赖不存在，所以依赖更早，但这样我们就无法执行删除文件的操作了，此时可以把clean定义为伪目标,就不会生成clean文件。</p><pre class="line-numbers language-none"><code class="language-none">.PHONY:cleanclean:rm $(objs) -f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h1><p>1、什么是GDB</p><ul><li><p>GDB是由GNU软件系统社区提供的调试工具，同GCC配套组成了一套完整的开发环境，GDB是Linux和许多类Unix系统中的标准开发环境。</p></li><li><p>一般来说，GDB主要帮助完成四个功能：</p><p>1、启动程序，可以按照自定义的要求随心所欲的运行程序</p><p>2、可让被调试的程序在所指定的调整的断点处停住（断点可以是条件表达式）</p><p>3、当程序被停住时，可以检查此程序中所发生的事</p><p>4、可以改变程序，将一个BUG产生的影响修正从而测试其他BUG</p></li></ul><p>2、准备工作：</p><ul><li><p>通常，在为调试而编译时，我们会关掉编译器的优化选项（‘-o’），并打开调试选项（‘-g’）。另外，     -Wall在尽量不影响程序行为的情况下选项打开所有warning，也可以发现许多问题，避免一些不必要的BUG。</p></li><li><p>```<br>gcc -g -Wall program.c -o program</p><pre class="line-numbers language-none"><code class="language-none">- -g的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件。3、GDB命令-启动、退出、查看代码- 启动和退出  gdb 可执行程序  quit- 给程序设置参数&#x2F;获取设置参数  set args 10 20  show args- GDB使用帮助  help- 查看当前文件代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>list/l (从默认位置显示)<br>list/l 行号 (从指定的行显示)<br>list/l 函数名 (从指定的函数显示)</p><pre class="line-numbers language-none"><code class="language-none">- 查看非当前文件代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>list/l 文件名:行号<br>list/l 文件名:函数名</p><pre class="line-numbers language-none"><code class="language-none">- 设置显示的行数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>show list/listsize<br>set list/listsize 行数</p><pre class="line-numbers language-none"><code class="language-none">4、GDB命令-断点操作- 设置断点  b&#x2F;break 行号  b&#x2F;break 函数名  b&#x2F;break 文件名:行号  b&#x2F;break 文件名:函数- 查看断点  i&#x2F;infob&#x2F;break- 删除断点  d&#x2F;del&#x2F;delete 断点编号- 设置断点无效  dis&#x2F;disable 断点编号- 设置断点生效  ena&#x2F;enable 断点编号- 设置条件断点（一般用在循环的位置）  b&#x2F;break 10 if i&#x3D;&#x3D;5(i是for循环的变量)5、GDB命令-调试命令- 运行GDB程序  start（程序停在第一行）  run（遇到断点才停）- 继续运行，到下一个断点停  c&#x2F;continue- 向下执行一行代码（不会进入函数体）  n&#x2F;next- 变量操作  p&#x2F;print变量名（打印变量值）  ptype变量名（打印变量类型）- 向下单步调试（遇到函数体进入函数体，与n&#x2F;next的区别）  s&#x2F;step  finish（跳出函数体）- 自动变量操作  display num(自动打印指定变量的值)  i&#x2F;info display  undisplay 编号- 其他操作  set var 变量名&#x3D;变量值  until （跳出循环）# 文件IO![5c20d8e2ddc1f12677e6a625ec2af83](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;fhc20001118&#x2F;images&#x2F;master&#x2F;img&#x2F;5c20d8e2ddc1f12677e6a625ec2af83.jpg)![e4b399af27ab67cdccd491e55c1b8cc](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;fhc20001118&#x2F;images&#x2F;master&#x2F;img&#x2F;e4b399af27ab67cdccd491e55c1b8cc.jpg)栈空间：从上往下存堆空间：从下往上存![d576a3afba826b5167dab97f0e111af](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;fhc20001118&#x2F;images&#x2F;master&#x2F;img&#x2F;d576a3afba826b5167dab97f0e111af.jpg)Linux系统IO函数：(lesson12)- &#96;&#96;&#96;  int open(const char *pathname, int flags);  int open(const char *pathname, int flags, mode_t mode);  int close(int fd);  ssize_t read(int fd, void *buf, size_t count);  ssize_t write(int fd, const void *buf, size_t count);  off_t lseek(int fd, off_t offset, int whence);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>在Linux中使用命令man 2 open可以阅读open函数文档</p><p><img src="https://raw.githubusercontent.com/fhc20001118/images/master/img/575441fa8498a08b90fb8fd8f4a6c79.jpg" alt="575441fa8498a08b90fb8fd8f4a6c79"></p><p>文件操作函数：(lesson13)</p><ul><li>```<br>int access(const char *pathname, int mode);<br>int chmode(const char *filename, int mode);<br>int chown(const char *path, uid_t owner, gid_t group);<br>int truncate(const char *path, off_t length);<pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>vim /etc/passwd 能够看到所有用户的所有者id<br>vim /etc/group 查看组id<pre class="line-numbers language-none"><code class="language-none">目录操作函数：(lesson14)- &#96;&#96;&#96;  int mkdir(const char *pathname, mode_t mode);  int rmdir(const cahr *pathname);  int rename(const cahr *oldpath, const char *newpath);  int chdir(const char *path);  char *getcwd(char *buf, size_t size);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>目录遍历函数：(lesson15)</p><ul><li>```<br>DIR *opendir(const char *name);<br>struct dirent *readdir(DIR *dirp);<br>int closedir(DIR *dirp);<pre class="line-numbers language-none"><code class="language-none">文件描述符：(lesson16)- &#96;&#96;&#96;  int dup(int oldfd);  int dup2(int oldfd, int newfd);  int fcntl(int fd, int cmd, ...&#x2F;*arg*&#x2F;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;注册信号捕捉时，struct-sigaction在vscode中报错（但是编译通过，运行也没有问题），查找大量资料发现原来是c编译器的标准问题，改为gnu17就不会报错了&quot;&gt;&lt;a href=&quot;#注册信号捕捉时，struct-sigaction在vscode中报错（</summary>
      
    
    
    
    <category term="webserver" scheme="http://fhc20001118.github.io/project/categories/webserver/"/>
    
    
    <category term="webserver" scheme="http://fhc20001118.github.io/project/tags/webserver/"/>
    
  </entry>
  
  <entry>
    <title>vscode</title>
    <link href="http://fhc20001118.github.io/project/2023/04/13/mac%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8tips/"/>
    <id>http://fhc20001118.github.io/project/2023/04/13/mac%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8tips/</id>
    <published>2023-04-12T16:00:00.000Z</published>
    <updated>2023-04-13T15:56:31.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用vscode免密远程连接服务器"><a href="#使用vscode免密远程连接服务器" class="headerlink" title="使用vscode免密远程连接服务器"></a>使用vscode免密远程连接服务器</h1><ol><li><p>本地主机终端</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssh-keygen&#x2F;&#x2F;会生成一个.ssh文件夹，打开文件夹中的公钥并复制（后缀为pub）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>服务器终端</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssh-keygen&#x2F;&#x2F;在生成的.ssh文件夹下创建一个文件vim authorized_keys&#x2F;&#x2F;把复制的公钥放入其中就可以，退出并保存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用vscode免密远程连接服务器&quot;&gt;&lt;a href=&quot;#使用vscode免密远程连接服务器&quot; class=&quot;headerlink&quot; title=&quot;使用vscode免密远程连接服务器&quot;&gt;&lt;/a&gt;使用vscode免密远程连接服务器&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;本</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://fhc20001118.github.io/project/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="vscode" scheme="http://fhc20001118.github.io/project/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>STL源码剖析</title>
    <link href="http://fhc20001118.github.io/project/2023/01/10/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://fhc20001118.github.io/project/2023/01/10/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</id>
    <published>2023-01-09T16:00:00.000Z</published>
    <updated>2023-04-13T15:45:56.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、空间配置器"><a href="#一、空间配置器" class="headerlink" title="一、空间配置器"></a>一、空间配置器</h1><h2 id="1-1-设计一个简单的空间配置器-JJ：allocator"><a href="#1-1-设计一个简单的空间配置器-JJ：allocator" class="headerlink" title="1.1 设计一个简单的空间配置器 JJ：allocator"></a>1.1 设计一个简单的空间配置器 JJ：allocator</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef _JJALLOC_#define _JJALLOC_#include &lt;new&gt; &#x2F;&#x2F; for palecement new#include &lt;cstddef&gt; &#x2F;&#x2F; for ptrdiff_t, size_t#include &lt;cstdlib&gt; &#x2F;&#x2F; for exit()#include &lt;climits&gt; &#x2F;&#x2F; for UINT_MAX#include &lt;iostream&gt; &#x2F;&#x2F; for cerrusing namespace std;namespace JJ &#123;    template &lt;class T&gt;    inline T* _allocate(ptrdiff_t size, T*) &#123;        set_new_handler(0);        T* tmp &#x3D; (T*)(::operator new ((size_t)(size* sizeof(T))));        if (tmp &#x3D;&#x3D; 0) &#123;            cerr &lt;&lt; &quot;out of memory&quot; &lt;&lt; endl;            exit(1);        &#125;        return tmp;    &#125;    template &lt;class T&gt;    inline void _deallocate(T* buffer) &#123;        ::operator delete(buffer);    &#125;    template &lt;class T1, class T2&gt;    inline void _construct(T1* p, const T2&amp; value) &#123;        new(p) T1(value);   &#x2F;&#x2F;placement new. invoke ctor of T1    &#125;    template &lt;class T&gt;    inline void _destroy(T* ptr) &#123;        ptr-&gt;~T();    &#125;    template &lt;class T&gt;    class allocator &#123;    public:        typedef T value_type;        typedef T* pointer;        typedef const T* const_pointer;        typedef T&amp; reference;        typedef const T&amp; const_reference;        typedef size_t size_type;        typedef ptrdiff_t difference_type;        &#x2F;&#x2F;rebind allocator of type U        template &lt;class U&gt;        struct rebind &#123;            typedef allocator&lt;U&gt; other;        &#125;;        &#x2F;&#x2F;hint used for locality        pointer allocate(size_type n, const void* hint&#x3D;0) &#123;            return JJ::_allocate((difference_type)n, (pointer)0);        &#125;        void deallocate(pointer p, size_type n) &#123; _deallocate(p);&#125;        void construct(pointer p, const T&amp; value) &#123;            _construct(p, value);        &#125;        void destroy(pointer p) &#123; _destroy(p);&#125;        pointer address(reference x) &#123; return (pointer)&amp;x; &#125;        const_pointer const_address(const_reference x) &#123;            return (const_pointer)&amp;x;        &#125;        size_type max_size() const &#123;            return size_type(UINT_MAX&#x2F;sizeof(T));        &#125;    &#125;;&#125;#endif &#x2F;&#x2F;_JJALLOC_<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    我们知道STL容器在不断保存数据时，当保存的的数据个数超过容器容量时，需要进行扩容。但是，当不断保存数据时，就可能需要不断的进行扩容。此时，扩容需要不断的向操作系统申请空间，释放空间。操作系统是很繁忙的，这样会大大影响操作系统的效率。</p><p><strong>空间配置器：是操作系统开辟的一大段内存空间。</strong>STL需要扩容申请内存时，就从空间配置器中申请，不需要再经过操作系统。并且，它还能回收释放的空间，供下一次使用。</p><p>优点：</p><ul><li>提高效率；STL容器申请空间不需要频繁向操作系统申请，而是需要向空间适配器申请，只是当空间适配器空间不够时，才会向操作系统申请。空间适配器还可以回收STL容器释放的空间，供下一次使用。</li><li>避免内存碎片；</li><li>更好地管理内存；</li></ul><h2 id="1-2-空间配置器基本原理"><a href="#1-2-空间配置器基本原理" class="headerlink" title="1.2 空间配置器基本原理"></a>1.2 空间配置器基本原理</h2><p>​    <strong>空间配置器有两级结构，一级空间配置器是用来处理大块内存，二级空间配置器处理小块内存。SGI-STL规定以128字节作为小块内存和大块内存的分界线。</strong></p><p><strong>为什么这样区分成两级？</strong></p><p><strong>因为STL容器，一般申请的都会是小块的内存。</strong></p><p><strong>二级空间配置器，主要是管理容器申请空间和释放的空间。</strong></p><p><strong>如果用户申请的空间直接大于的128字节直接找的是一级空间配置器申请空间。</strong></p><h2 id="二、序列式容器"><a href="#二、序列式容器" class="headerlink" title="二、序列式容器"></a>二、序列式容器</h2><h3 id="2-1-序列式容器"><a href="#2-1-序列式容器" class="headerlink" title="2.1 序列式容器"></a>2.1 序列式容器</h3><p>​    所谓序列式容器，其中的元素都可序，但未必有序。c++本身提供了一个序列式容器array，STL再另外提供vector，list，deque，stack，queue，priority-queue等序列式容器。</p><h3 id="2-2-vector"><a href="#2-2-vector" class="headerlink" title="2.2 vector"></a>2.2 vector</h3><h4 id="2-2-1-vector概述"><a href="#2-2-1-vector概述" class="headerlink" title="2.2.1 vector概述"></a>2.2.1 vector概述</h4><p>​    vector的数据安排以及操作方式，与array非常相似，两者差别在于空间运用的灵活性。array是静态空间，一旦配置就不能改变。vector是动态空间，随着元素的加入，它的内部机制会自行扩充空间容纳新的元素。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、空间配置器&quot;&gt;&lt;a href=&quot;#一、空间配置器&quot; class=&quot;headerlink&quot; title=&quot;一、空间配置器&quot;&gt;&lt;/a&gt;一、空间配置器&lt;/h1&gt;&lt;h2 id=&quot;1-1-设计一个简单的空间配置器-JJ：allocator&quot;&gt;&lt;a href=&quot;#1-1-</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://fhc20001118.github.io/project/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="c++,STL" scheme="http://fhc20001118.github.io/project/tags/c-STL/"/>
    
  </entry>
  
  <entry>
    <title>c++学习笔记</title>
    <link href="http://fhc20001118.github.io/project/2022/12/31/c++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://fhc20001118.github.io/project/2022/12/31/c++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-12-30T16:00:00.000Z</published>
    <updated>2023-01-08T13:21:39.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、文件输入-输出"><a href="#1、文件输入-输出" class="headerlink" title="1、文件输入/输出"></a>1、文件输入/输出</h1><p>输出的主要步骤：</p><ol><li><p>包含头文件fsteam</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;fsteam&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建一个ofsteam对象</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ofsteam outFile;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>将该ofsteam对象同一个文件关联起来</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">outFile.open(&quot;fish.txt&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>就像使用cout那样使用该ofsteam对象</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">outFile &lt;&lt; &quot;hello world!&quot; &lt;&lt; end;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​</p></li></ol><h1 id="2、函数探幽"><a href="#2、函数探幽" class="headerlink" title="2、函数探幽"></a>2、函数探幽</h1><h2 id="2-1-c-内联函数"><a href="#2-1-c-内联函数" class="headerlink" title="2.1 c++内联函数"></a>2.1 c++内联函数</h2><p>​    内联函数的编译代码与其他程序代码内联起来，编译器将使用相应的函数代码替换函数调用。对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来，因此，内联函数的运行速度比常规函数稍快，但代价是要占用更多的内存。</p><p>要使用这项特性，必须采取下述措施之一：</p><ul><li>在函数声明前加上关键字inline</li><li>在函数定义前加上关键字inline</li></ul><h2 id="2-2-引用变量"><a href="#2-2-引用变量" class="headerlink" title="2.2 引用变量"></a>2.2 引用变量</h2><p>注意：必须在声明引用是将其初始化</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a;int &amp;b;b &#x3D; a;&#x2F;&#x2F;这样不被允许<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>引用就是变量的别名</p><p>引用参数、const、临时变量，什么时候会产生临时变量？</p><ul><li>实参的类型正确，但不是左指</li><li>实参的类型不正确，但可以转换为正确的类型</li></ul><p>使用const关键字后，当实参和引用参数不匹配，c++将生成临时变量（不能取地址用const引用）</p><h2 id="2-3-默认参数"><a href="#2-3-默认参数" class="headerlink" title="2.3 默认参数"></a>2.3 默认参数</h2><p>如果调用函数时并没有传入参数，将会使用默认参数；比如left(”theory“，3)表示截取前三个字符，left(“theory”)表示默认截取一个字符</p><p>如何设置默认参数？</p><p>char *left(const char *str, int n = 1)；</p><p>注意：</p><p>设置默认参数时必须从右往左设置，下面这种情况是不被允许的</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int chico(int n, int m &#x3D; 6, int j); &#x2F;&#x2F;invalid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-3-函数重载"><a href="#2-3-函数重载" class="headerlink" title="2.3 函数重载"></a>2.3 函数重载</h2><p>根据上下文推断出相同的函数不同的作用。</p><p>函数重载的关键是函数的参数列表。</p><h2 id="2-4-内存模型和名称"><a href="#2-4-内存模型和名称" class="headerlink" title="2.4 内存模型和名称"></a>2.4 内存模型和名称</h2><h3 id="2-4-1-单独编译"><a href="#2-4-1-单独编译" class="headerlink" title="2.4.1 单独编译"></a>2.4.1 单独编译</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;&gt;&#x2F;&#x2F;如果文件名包含在尖括号中，则c++编译器将在存储标准头文件的主机系统的文件系统中查找#include &quot;&quot;&#x2F;&#x2F;如果文件名包含在双引号中，则编译器将首先查找当前的工作目录或源代码目录，如果没有在那找到头文件，则将在标准位置查找<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因此在包含自己的头文件时，应使用引号而不是尖括号。</p><p>如何防止头文件被包含多次？</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef COORDIN_H_&#x2F;&#x2F;if not define#define COORDIN_H_&#x2F;&#x2F;如果第一次包含这个头文件，是没有定义COORDIN_H_的，因此会进入该判断语句&#x2F;&#x2F;若第二次包含该头文件，由于之前已经创建过了COORDIN_H_这个定义，因此不会进入该循环#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还可以用下面这种</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#pragma once;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-4-2-存储持续性、作用域和链接性"><a href="#2-4-2-存储持续性、作用域和链接性" class="headerlink" title="2.4.2 存储持续性、作用域和链接性"></a>2.4.2 存储持续性、作用域和链接性</h3><ul><li>自动存储持续性：在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放。</li><li>静态存储持续性：在函数定义外定义的变量和使用关键字static定义的变量的存储持续性都为静态的。它们在程序整个运行过程中都存在。</li><li>线程存储持续性：当前多核处理器很常见，这些cpu可同时处理多个执行任务。这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字thread_local声明的</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、文件输入-输出&quot;&gt;&lt;a href=&quot;#1、文件输入-输出&quot; class=&quot;headerlink&quot; title=&quot;1、文件输入/输出&quot;&gt;&lt;/a&gt;1、文件输入/输出&lt;/h1&gt;&lt;p&gt;输出的主要步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;包含头文件fsteam&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://fhc20001118.github.io/project/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="c++" scheme="http://fhc20001118.github.io/project/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法刷题笔记</title>
    <link href="http://fhc20001118.github.io/project/2022/12/17/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://fhc20001118.github.io/project/2022/12/17/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2022-12-16T16:00:00.000Z</published>
    <updated>2022-12-17T07:58:46.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、摆动序列"><a href="#1、摆动序列" class="headerlink" title="1、摆动序列"></a>1、摆动序列</h2><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><ul><li>输入: [1,17,5,10,13,15,10,5,16,8]</li><li>输出: 7</li><li>解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</li></ul><p>这道题既可以用贪心也可以用动态规划！</p><p>一正一负的交替很容易想到一小一大的交替，如果要找到最长的序列就要遍历很多次，但是这样做就是暴力了而不是贪心；当我们画出图后可以发现，很像数学中的函数的峰值，我们要找的就是极大值或极小值的点，他们构成的序列一定是最长的摆动序列！</p><p><img src="https://img-blog.csdnimg.cn/20201124174327597.png" alt="376.摆动序列"></p><p>前一个坡度设为preDiff，后一个坡度当前坡度curDiff，初始值都为0，只有当坡度一正一负时，才可以构成最长的序列（当然存在在坡上的点也可以构成最长序列的情况，但是这个方法是一定可以构成的）证实了“局部最优解构成全局最优解”</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;        if (nums.size() &lt;&#x3D; 1) return nums.size();        int curDiff &#x3D; 0;&#x2F;&#x2F;当前峰值        int preDiff &#x3D; 0;&#x2F;&#x2F;前一个峰值        int res &#x3D; 1;&#x2F;&#x2F;默认最右边有一个峰值        for (int i &#x3D; 0; i &lt; nums.size()-1; i++) &#123;            curDiff &#x3D; nums[i+1] - nums[i];            if ((curDiff &gt; 0 &amp;&amp; preDiff &lt;&#x3D; 0) || (curDiff &lt; 0 &amp;&amp; preDiff &gt;&#x3D; 0)) &#123;                res++;                preDiff &#x3D; curDiff;            &#125;        &#125;        return res;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ol><li><p><strong>curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0，为什么cur不能等于0？</strong></p><p>因为pre初值为0，当只有两个数时，如果他们不相等，那一定是有坡度的，也就是说cur一定是大于0或者小于0，此时满足条件res++；两个数相等的话，cur等于0，此时他们没有坡度，res不能增加，只能返回1，因此不能curDiff &gt;= 0或者curDiff &lt;= 0,这样会导致有两个相等的数时也会增加序列长度。</p></li><li><p><strong>i要小于nuts.size()-1，不要越界了。</strong></p></li></ol><h2 id="2、最大子序和"><a href="#2、最大子序和" class="headerlink" title="2、最大子序和"></a>2、最大子序和</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><h3 id="贪心解法"><a href="#贪心解法" class="headerlink" title="贪心解法"></a>贪心解法</h3><p><strong>贪心贪的是哪里呢？</strong></p><p>如果 -2 1 在一起，计算起点的时候，一定是从1开始计算，因为负数只会拉低总和，这就是贪心贪的地方！</p><p>局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</p><p>全局最优：选取最大“连续和”</p><p><strong>局部最优的情况下，并记录最大的“连续和”，可以推出全局最优</strong>。</p><p>从代码角度上来讲：遍历nums，从头开始用count累积，如果count一旦加上nums[i]变为负数，那么就应该从nums[i+1]开始从0累积count了，因为已经变为负数的count，只会拖累总和。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int result &#x3D; INT_MIN;        int count &#x3D; 0;        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;            count +&#x3D; nums[i];            if (count &gt; result) &#123; &#x2F;&#x2F; 取区间累计的最大值（相当于不断确定最大子序终止位置）                result &#x3D; count;            &#125;            if (count &lt;&#x3D; 0) count &#x3D; 0; &#x2F;&#x2F; 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和        &#125;        return result;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://code-thinking.cdn.bcebos.com/gifs/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.gif" alt="53.最大子序和"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、摆动序列&quot;&gt;&lt;a href=&quot;#1、摆动序列&quot; class=&quot;headerlink&quot; title=&quot;1、摆动序列&quot;&gt;&lt;/a&gt;1、摆动序列&lt;/h2&gt;&lt;p&gt;如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或</summary>
      
    
    
    
    <category term="算法" scheme="http://fhc20001118.github.io/project/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="贪心算法" scheme="http://fhc20001118.github.io/project/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法刷题笔记</title>
    <link href="http://fhc20001118.github.io/project/2022/11/28/c++%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <id>http://fhc20001118.github.io/project/2022/11/28/c++%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</id>
    <published>2022-11-27T16:00:00.000Z</published>
    <updated>2022-12-16T03:33:08.151Z</updated>
    
    <content type="html"><![CDATA[<p>回溯算法能解决的问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>棋盘问题：N皇后，解数独等等</li></ul><h2 id="1、组合总和"><a href="#1、组合总和" class="headerlink" title="1、组合总和"></a>1、组合总和</h2><p>难点：1）普通的结束条件是当track中所有数的和等于target时就把track加入到结果数组中，如何优化？</p><p>​            2）如果使用正常的回溯算法会得到结果[2,2,3],[2,3,2],[3,2,2]这样重复的答案，如何去重？</p><p><img src="https://raw.githubusercontent.com/fhc20001118/images/master/img/image-20221027164534105.png" alt="image-20221027164534105"></p><p>优化1：</p><p>每次从选择列表中选出一个数，就用target减去这个数对应的值，这样就不必计算track的和，结束条件就变为 target == 0；非法条件就变为 target &lt; 0。</p><p><img src="https://pic.leetcode-cn.com/1598091943-hZjibJ-file_1598091940241" alt="img"></p><p>优化2：</p><p>​    产生重复的原因：在每一个结点做减法展开分支的时候，使用了之前也使用过的数字</p><p>​    解决办法：<strong>每一次搜索的时候设置下一次搜索的起点</strong>，不要每次从头开始遍历</p><p><img src="https://pic.leetcode-cn.com/1598091943-GPoHAJ-file_1598091940246" alt="img"></p><p>代码实现：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;vector&lt;int&gt;&gt;res;vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;    vector&lt;int&gt;track;&#x2F;&#x2F;路径    backtrack(track, candidates, 0, target);    return res;&#125;void backtrack(vector&lt;int&gt;&amp; track, vector&lt;int&gt;&amp; candidates, int begin, int target) &#123;    &#x2F;&#x2F;结束条件，如果遍历到叶节点 0    if (target &#x3D;&#x3D; 0) &#123;        res.push_back(track);        return;    &#125;    &#x2F;&#x2F;遍历决策树    for (int i &#x3D; begin; i &lt; candidates.size(); i++) &#123;        &#x2F;&#x2F;因为可以有重复，所以不用判断是否使用了        &#x2F;&#x2F;跳过非法条件        if (target &lt; 0) continue;        &#x2F;&#x2F;做出选择        track.push_back(candidates[i]);        int k &#x3D; target - candidates[i];        &#x2F;&#x2F;进入下一层决策树        &#x2F;&#x2F;因为可以使用重复元素，所以下一次搜索的起点可以从自己开始，所以还是i        backtrack(track, candidates, i, k);        &#x2F;&#x2F;撤销选择        track.pop_back();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、组合总和II"><a href="#2、组合总和II" class="headerlink" title="2、组合总和II"></a>2、组合总和II</h2><p>难点：与I的区别是，每个数字只能使用一次，但是每个数字有多个相同的，如何去除重复的答案？</p><p><img src="https://raw.githubusercontent.com/fhc20001118/images/master/img/image-20221027193147819.png" alt="image-20221027193147819"></p><p>解决：</p><p>​    先把candidates中的数字进行排序，这样相同的数就会相邻；</p><p>​    然后跳过对同一结点下相等的分支的搜索（比如在结点4中，跳过了对后面两个2的搜索）；</p><p> （后面为2的分支得到的结果只会比第一个2的少，并且是它的真子集，所以没有必要）</p><p>​    <img src="https://pic.leetcode-cn.com/1599718525-iXEiiy-image.png" alt="image.png"></p><p>代码实现：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">sort(candidates.begin(), candidates.end());&#x2F;&#x2F;排序<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;剪枝优化(关键代码)void backtrack(vector&lt;int&gt;&amp; track, vector&lt;int&gt;&amp; candidates, int begin, int target) &#123;        &#x2F;&#x2F;结束条件        if (target &#x3D;&#x3D; 0) &#123;            res.push_back(track);            return;        &#125;        for (int i &#x3D; begin; i &lt; candidates.size(); i++) &#123;            &#x2F;&#x2F;跳过非法条件            if (target &lt; 0 ) continue;            &#x2F;&#x2F;i &gt; begin的意思是下一个分支，直到找到下一个分支与相邻的分支不等的时候            if (i &gt; begin &amp;&amp; candidates[i] &#x3D;&#x3D; candidates[i-1]) continue;            &#x2F;&#x2F;做出选择            track.push_back(candidates[i]);            &#x2F;&#x2F;从i+1开始是因为自己只能使用一次            &#x2F;&#x2F;进入下一层决策树            backtrack(track, candidates, i+1, target-candidates[i]);            &#x2F;&#x2F;撤销选择            track.pop_back();        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、全排列II"><a href="#3、全排列II" class="headerlink" title="3、全排列II"></a>3、全排列II</h2><p>难点：如何去重？</p><p><img src="https://raw.githubusercontent.com/fhc20001118/images/master/img/image-20221027210609901.png" alt="image-20221027210609901"></p><p>解决：</p><p>​    全排列和组合的区别是，全排列每次要<strong>重头</strong>遍历整个选择列表；</p><p>​    去除相同的数字导致的重复的关键是把nums排序；</p><p>​    但是为了避免出现选择了刚刚选过的数字，用visited数组来标记；</p><p>代码块：</p><p>​    </p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void backtrack(vector&lt;int&gt;&amp; track, vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; visited) &#123;        &#x2F;&#x2F;满足结束条件，返回        if (track.size() &#x3D;&#x3D; nums.size()) &#123;            res.push_back(track);            return;        &#125;        &#x2F;&#x2F;遍历选择列表        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;            &#x2F;&#x2F;跳过非法条件            if (visited[i] &#x3D;&#x3D; 1) continue; &#x2F;&#x2F;如果当前数字已经使用过了就跳过            &#x2F;&#x2F;如果当前分支和前一个分支相同，并且前一个分支还未使用的时候跳过            &#x2F;&#x2F;其实就是选择了重复元素的第一个            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i-1] &amp;&amp; visited[i-1] &#x3D;&#x3D; 0) continue;                        &#x2F;&#x2F;做出选择            visited[i] &#x3D; 1;            track.push_back(nums[i]);            &#x2F;&#x2F;进入下一层决策树            backtrack(track, nums, visited);            &#x2F;&#x2F;撤销选择            visited[i] &#x3D; 0;            track.pop_back();        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、递增子序列"><a href="#3、递增子序列" class="headerlink" title="3、递增子序列"></a>3、递增子序列</h2><p><img src="https://raw.githubusercontent.com/fhc20001118/images/master/img/image-20221028152434805.png" alt="image-20221028152434805"></p><p>​    两个地方需要剪枝：</p><p>​    1、当前选择的结点比父节点小（也就是路径中最后的值）</p><p>​    2、同一层中有数字相等的分支（不管相不相邻）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void backtrack(vector&lt;int&gt;&amp; track, vector&lt;int&gt;&amp; nums, int begin) &#123;        &#x2F;&#x2F;这里是判断是否到叶子结点的结束条件，但是有的结果不是叶子结点，所以不需要结束条件        unordered_set&lt;int&gt;brothers;        &#x2F;&#x2F;遍历决策树        for (int i &#x3D; begin; i &lt; nums.size(); i++) &#123;            &#x2F;&#x2F;跳过非法条件            if (!track.empty() &amp;&amp; nums[i] &lt; track.back()) continue;            &#x2F;&#x2F;同一层出现数字相等的分支（不管相不相邻）            if (brothers.count(nums[i])) continue;            &#x2F;&#x2F;做出选择            track.push_back(nums[i]);            brothers.insert(nums[i]);            if (track.size() &gt;&#x3D; 2) res.push_back(track);            &#x2F;&#x2F;进入下一层决策树            backtrack(track, nums, i+1);            &#x2F;&#x2F;撤销选择            &#x2F;&#x2F;这里为什么不用brothers.erase(nums[i])?            &#x2F;&#x2F;因为brothers存放的是这一层使用过的结点，这个撤销只是说他用完了，而不是没用过            track.pop_back();        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><p>​    这道题与求子集问题II类似，也可以用处理同一层兄弟结点的方式去重，但是！！！子集问题一定要排序！一定要排序！一定要排序！否则就会如下图</p><p><img src="https://img-blog.csdnimg.cn/2020111316440479.png" alt="90.子集II2"></p><h2 id="4、电话号码的字母组合"><a href="#4、电话号码的字母组合" class="headerlink" title="4、电话号码的字母组合"></a>4、电话号码的字母组合</h2><p><img src="https://raw.githubusercontent.com/fhc20001118/images/master/img/image-20221028164739868.png" alt="image-20221028164739868"></p><p>​    1）如何映射？</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">private:&#x2F;&#x2F;创建了一个字符串的二维数组    const string letterMap[10] &#x3D; &#123;            &quot;&quot;, &#x2F;&#x2F; 0            &quot;&quot;, &#x2F;&#x2F; 1            &quot;abc&quot;, &#x2F;&#x2F; 2            &quot;def&quot;, &#x2F;&#x2F; 3            &quot;ghi&quot;, &#x2F;&#x2F; 4            &quot;jkl&quot;, &#x2F;&#x2F; 5            &quot;mno&quot;, &#x2F;&#x2F; 6            &quot;pqrs&quot;, &#x2F;&#x2F; 7            &quot;tuv&quot;, &#x2F;&#x2F; 8            &quot;wxyz&quot;, &#x2F;&#x2F; 9    &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    2）采用传参index的方式遍历digits，同时注意结束条件是当index == digits.size()的时候</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void backtrack(string&amp; s, string&amp; digits, int index) &#123;        &#x2F;&#x2F;结束条件    &#x2F;&#x2F;index也代表决策树的高度        if (index &#x3D;&#x3D; digits.size()) &#123;            res.push_back(s);            return;        &#125;        int digit &#x3D; digits[index] - &#39;0&#39;;        string letters &#x3D; letterMap[digit];&#x2F;&#x2F;选择列表        for (int i &#x3D; 0; i &lt; letters.size(); i++) &#123;            &#x2F;&#x2F;跳过非法条件,这里没有            &#x2F;&#x2F;做出选择            s.push_back(letters[i]);            &#x2F;&#x2F;进入下一层决策树            backtrack(s, digits, index+1);            &#x2F;&#x2F;撤销选择            s.pop_back();        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、分割回文串"><a href="#5、分割回文串" class="headerlink" title="5、分割回文串"></a>5、分割回文串</h2><p><img src="https://raw.githubusercontent.com/fhc20001118/images/master/img/image-20221028174706364.png" alt="image-20221028174706364"></p><p>​    1）截取子串的决策树怎么画？</p><p>​    切割问题也可以抽象为一颗决策树</p><p><img src="https://pic.leetcode-cn.com/298a80282ac3505fec3710abdc1e656c591cf7acaa3ba976151480729244b649-image.png" alt="image.png"></p><p>​    解释：</p><p>​    track保存的是路径上的信息</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void backtrack(vector&lt;string&gt;&amp; track, const string&amp; s, int begin) &#123;        &#x2F;&#x2F;结束条件:当截取到字符串末尾时        if (begin &#x3D;&#x3D; s.size()) &#123;            res.push_back(track);            return;        &#125;        &#x2F;&#x2F;遍历决策树        for (int i &#x3D; begin; i &lt; s.size(); i++) &#123;            &#x2F;&#x2F;跳过非法条件:不是回文            if (!isPalindrome(s, begin, i)) continue;            &#x2F;&#x2F;做出选择            string str &#x3D; s.substr(begin, i-begin+1);&#x2F;&#x2F;s.substr(pos, len) pos指起始位置，len指截取的长度            track.push_back(str);            &#x2F;&#x2F;进入下一层决策树            backtrack(track, s, i+1);            &#x2F;&#x2F;撤销选择            track.pop_back();        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6、复原ip地址"><a href="#6、复原ip地址" class="headerlink" title="6、复原ip地址"></a>6、复原ip地址</h2><p>类似于分割字符串，但是这里有很多细节要处理好</p><p>注意：</p><p>​    1、可以直接写一个判断当前分割的子串是否合法的函数，不用在回溯函数里一个个判断，而且到达结束条件的时候还要判断最后一个子字符串是否合法，才能把它加入结果数组</p><p>​    2、记住怎么把字符串变成整型</p><p>​    3、插入点而不是插入字符串，这样操作很方便，撤销的时候也是把刚刚在那个地方插入的点撤销</p><p>​    4、没有使用track保存路径，而是直接在字符串上进行操作，因为返回的是一个一维的字符串数组</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool isValid(const string&amp; s, int start, int end) &#123;        &#x2F;&#x2F;到达字符串末尾了        if (start &gt; end) return false;        if (s[start] &#x3D;&#x3D; &#39;0&#39; &amp;&amp; start !&#x3D; end) return false;        int num &#x3D; 0;        for (int i &#x3D; start; i &lt;&#x3D; end; i++) &#123;            if (s[i] &gt; &#39;9&#39; || s[i] &lt; &#39;0&#39;) return false;            num &#x3D; num * 10 + (s[i] - &#39;0&#39;);            if (num &gt; 255) return false;        &#125;        return true;    &#125;    void backtrack(string&amp; s, int begin, int pointNum) &#123;        &#x2F;&#x2F;结束条件：当有三个点时，分割结束        if (pointNum &#x3D;&#x3D; 3) &#123;            &#x2F;&#x2F;判断第四段子串是否合法            if (isValid(s, begin, s.size()-1)) &#123;                res.push_back(s);                return;            &#125;        &#125;                &#x2F;&#x2F;做出选择        for (int i &#x3D; begin; i &lt; s.size(); i++) &#123;            &#x2F;&#x2F;跳过非法条件：当前子串是否合法            if (!isValid(s, begin, i)) continue;            &#x2F;&#x2F;做出选择，插入点            s.insert(s.begin()+i+1, &#39;.&#39;);            &#x2F;&#x2F;进入下一层决策树            &#x2F;&#x2F;注意是i+2，因为插入了一个点            backtrack(s, i+2, pointNum+1);            &#x2F;&#x2F;撤销选择，删除点            s.erase(s.begin()+i+1);        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7、重新安排行程"><a href="#7、重新安排行程" class="headerlink" title="7、重新安排行程"></a>7、重新安排行程</h2><p><a href="#https://www.programmercarl.com/0332.重新安排行程.html#该记录映射关系">代码随想录</a></p><p>决策树也比较难想得到，要是能画出决策树，也不难</p><p><img src="https://img-blog.csdnimg.cn/2020111518065555.png" alt="332.重新安排行程1"></p><p>此部分内容代码随想录讲的很好</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123;        vector&lt;string&gt;track;        &#x2F;&#x2F;初始化航班的映射，制作选择列表        for (const vector&lt;string&gt;&amp; vec : tickets) &#123;            targets[vec[0]][vec[1]]++;        &#125;        &#x2F;&#x2F;初始化        track.push_back(&quot;JFK&quot;);        backtrack(track, tickets);        return res;    &#125;    bool backtrack(vector&lt;string&gt;&amp; track, const vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123;        &#x2F;&#x2F;结束条件：如果结果数组的长度等于航班+1        if (track.size() &#x3D;&#x3D; tickets.size()+1) &#123;            res &#x3D; track;             return true;        &#125;        for (pair&lt;const string, int&gt;&amp; target : targets[track[track.size()-1]]) &#123;            &#x2F;&#x2F;跳过非法条件，可以起飞的次数为0            &#x2F;&#x2F;if (target.second &lt;&#x3D; 0) continue;            if (target.second &gt; 0) &#123;                &#x2F;&#x2F;做出选择                &#x2F;&#x2F;cout &lt;&lt; target.first &lt;&lt; endl;;                track.push_back(target.first);                target.second--;                if (backtrack(track, tickets)) return true; &#x2F;&#x2F;这样就会保留第一条满足条件的路径，当然也是正确答案                &#x2F;&#x2F;撤销选择                track.pop_back();                target.second++;            &#125;        &#125;        return false;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意这里题目条件是按字典排序，因此用map拍好了选择的序列，所以第一条正确的路径即为答案，因此我们可以用bool型作为返回类型</p><h2 id="8、解数独"><a href="#8、解数独" class="headerlink" title="8、解数独"></a>8、解数独</h2><p>这道题结合了“N皇后” 和 “重新安排行程” 两个问题</p><p>选择列表就是1~9这9个数字，结果数组就是棋盘board</p><p>这道题的决策树也比较难，相同层的分支是同一个位置的不同选择，不同层的分支是下一个位置的不同选择，所以进入下一层决策树就是在下一个位置进行选择，因此相同层的for循环遍历应该是双循环，从上往下、从左往右遍历整个棋盘，每个空位置选择完毕就进入下一个空位置（也就是下一层决策树）进行选择</p><p><img src="https://img-blog.csdnimg.cn/2020111720451790.png" alt="37.解数独"></p><p>在每个空位进行选择数字的时候要判断合法性</p><p>​    1、同一行不能重复</p><p>​    2、同一列不能重复</p><p>​    3、同一个九宫格不能重复（如何判断是否在同一个九宫格也是个难点，具体看代码注释）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool isValid(int row, int col, char val, const vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;        &#x2F;&#x2F;同一行不能重复        for (int i &#x3D; 0; i &lt; 9; i++) &#123;            if (board[row][i] &#x3D;&#x3D; val) return false;        &#125;        &#x2F;&#x2F;同一列不能重复        for (int i &#x3D; 0; i &lt; 9; i++) &#123;            if (board[i][col] &#x3D;&#x3D; val) return false;        &#125;        &#x2F;&#x2F;同一个九宫格不能重复        &#x2F;&#x2F;除代表是第几个九宫格，乘代表一个九宫格长度为3，比如行在第2个九宫格，那么前面的长度就是6，所以行从6开始        int startRow &#x3D; (row &#x2F; 3) * 3;         int startCol &#x3D; (col &#x2F; 3) * 3;        for (int i &#x3D; startRow; i &lt; startRow+3; i++) &#123;            for (int j &#x3D;startCol; j &lt; startCol+3; j++) &#123;                if (board[i][j] &#x3D;&#x3D; val) return false;            &#125;        &#125;                return true;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回溯代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;因为找到一个满足答案的路径就行，所以用bool    bool backtrack(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;        for (int i &#x3D; 0; i &lt; 9; i++) &#123;            for (int j &#x3D; 0; j &lt; 9; j++) &#123;                &#x2F;&#x2F;跳过非法条件                if (board[i][j] !&#x3D; &#39;.&#39;) continue;                for (char k &#x3D;&#39;1&#39;; k &lt;&#x3D; &#39;9&#39;; k++) &#123;                    if (isValid(i, j, k, board)) &#123;                        &#x2F;&#x2F;做出选择                        board[i][j] &#x3D; k;                        if (backtrack(board)) return true;                        &#x2F;&#x2F;撤销选择                        board[i][j] &#x3D; &#39;.&#39;;                    &#125;                &#125;                &#x2F;&#x2F;试完9个数都不行                &#x2F;&#x2F;为什么把fasle放在k的for循环外呢？                &#x2F;&#x2F;因为如果你这个数可以放在这个位置，就一定会进入下一层继续放下一个位置                &#x2F;&#x2F;反之，当你这个for循环把1~9都找遍了也放不了，那一定就会出循环，不会进入下一层，那么此时   就应该判断前面肯定有些数字选错了                &#x2F;&#x2F;所以出循环一定返回false                return false;            &#125;        &#125;        return true;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;回溯算法能解决的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组合问题：N个数里面按一定规则找出k个数的集合&lt;/li&gt;
&lt;li&gt;排列问题：N个数按一定规则全排列，有几种排列方式&lt;/li&gt;
&lt;li&gt;切割问题：一个字符串按一定规则有几种切割方式&lt;/li&gt;
&lt;li&gt;子集问题：一个N个数的集合</summary>
      
    
    
    
    <category term="算法" scheme="http://fhc20001118.github.io/project/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="回溯" scheme="http://fhc20001118.github.io/project/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>二分查找刷题笔记</title>
    <link href="http://fhc20001118.github.io/project/2022/11/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://fhc20001118.github.io/project/2022/11/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2022-11-27T16:00:00.000Z</published>
    <updated>2022-12-16T03:30:19.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、二分查找模板"><a href="#1、二分查找模板" class="headerlink" title="1、二分查找模板"></a>1、二分查找模板</h2><p>模板一：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int left &#x3D; 0;        int right &#x3D; nums.size() - 1; &#x2F;&#x2F; 定义target在左闭右闭的区间里，[left, right]        while (left &lt;&#x3D; right) &#123; &#x2F;&#x2F; 当left&#x3D;&#x3D;right，区间[left, right]依然有效，所以用 &lt;&#x3D;            int middle &#x3D; left + ((right - left) &#x2F; 2);&#x2F;&#x2F; 防止溢出 等同于(left + right)&#x2F;2            if (nums[middle] &gt; target) &#123;                right &#x3D; middle - 1; &#x2F;&#x2F; target 在左区间，所以[left, middle - 1]            &#125; else if (nums[middle] &lt; target) &#123;                left &#x3D; middle + 1; &#x2F;&#x2F; target 在右区间，所以[middle + 1, right]            &#125; else &#123; &#x2F;&#x2F; nums[middle] &#x3D;&#x3D; target                return middle; &#x2F;&#x2F; 数组中找到目标值，直接返回下标            &#125;        &#125;        &#x2F;&#x2F; 未找到目标值        return -1;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>模板二：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int left &#x3D; 0;        int right &#x3D; nums.size(); &#x2F;&#x2F; 定义target在左闭右开的区间里，即：[left, right)        while (left &lt; right) &#123; &#x2F;&#x2F; 因为left &#x3D;&#x3D; right的时候，在[left, right)是无效的空间，所以使用 &lt;            int middle &#x3D; left + ((right - left) &gt;&gt; 1);            if (nums[middle] &gt; target) &#123;                right &#x3D; middle; &#x2F;&#x2F; target 在左区间，在[left, middle)中            &#125; else if (nums[middle] &lt; target) &#123;                left &#x3D; middle + 1; &#x2F;&#x2F; target 在右区间，在[middle + 1, right)中            &#125; else &#123; &#x2F;&#x2F; nums[middle] &#x3D;&#x3D; target                return middle; &#x2F;&#x2F; 数组中找到目标值，直接返回下标            &#125;        &#125;        &#x2F;&#x2F; 未找到目标值        return -1;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="解释一下左移和右移：x-lt-lt-y-相当于x-2-y-，x-gt-gt-y-相当于x-2-y"><a href="#解释一下左移和右移：x-lt-lt-y-相当于x-2-y-，x-gt-gt-y-相当于x-2-y" class="headerlink" title="解释一下左移和右移：x &lt;&lt; y 相当于x * 2^y ，x &gt;&gt; y 相当于x  /  2^y"></a>解释一下左移和右移：x &lt;&lt; y 相当于x * 2^y ，x &gt;&gt; y 相当于x  /  2^y</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、二分查找模板&quot;&gt;&lt;a href=&quot;#1、二分查找模板&quot; class=&quot;headerlink&quot; title=&quot;1、二分查找模板&quot;&gt;&lt;/a&gt;1、二分查找模板&lt;/h2&gt;&lt;p&gt;模板一：&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-c++</summary>
      
    
    
    
    <category term="算法" scheme="http://fhc20001118.github.io/project/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二分查找" scheme="http://fhc20001118.github.io/project/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>二叉树刷题笔记</title>
    <link href="http://fhc20001118.github.io/project/2022/11/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://fhc20001118.github.io/project/2022/11/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2022-11-27T16:00:00.000Z</published>
    <updated>2022-12-16T03:30:00.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、求二叉树的最小深度"><a href="#1、求二叉树的最小深度" class="headerlink" title="1、求二叉树的最小深度"></a>1、求二叉树的最小深度</h2><p>与求二叉树最大深度不一样，如果直接像求二叉树最大深度那样递归求二叉树的最小深度，答案会错，因为当二叉树的左子树为空时，就会认为最小深度应该为1，这是错的；</p><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20221103145212320.png" alt="image-20221103145212320"></p><p>因此递归应该添加条件：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int leftDepth &#x3D; getDepth(node-&gt;left);           &#x2F;&#x2F; 左int rightDepth &#x3D; getDepth(node-&gt;right);         &#x2F;&#x2F; 右                                                &#x2F;&#x2F; 中&#x2F;&#x2F; 当一个左子树为空，右不为空，这时并不是最低点if (node-&gt;left &#x3D;&#x3D; NULL &amp;&amp; node-&gt;right !&#x3D; NULL) &#123;     return 1 + rightDepth;&#125;   &#x2F;&#x2F; 当一个右子树为空，左不为空，这时并不是最低点if (node-&gt;left !&#x3D; NULL &amp;&amp; node-&gt;right &#x3D;&#x3D; NULL) &#123;     return 1 + leftDepth;&#125;int result &#x3D; 1 + min(leftDepth, rightDepth);return result;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>当然，求最短深度可以等价为求最短路径，可以采用BFS算法</strong></p><h2 id="2、二叉树的所有路径"><a href="#2、二叉树的所有路径" class="headerlink" title="2、二叉树的所有路径"></a>2、二叉树的所有路径</h2><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20221102150620793.png" alt="image-20221102150620793"></p><p>这道题就是用回溯的方法写的，前序遍历的递归就是一个回溯算法，并且<strong>递归和回溯要一一对应</strong>（后面的代码中会提到），难点在于细节处理，用什么保存路径？</p><p>如果用字符串temp来保存路径，当回溯的时候就会很麻烦，因为还要把“-&gt;”给删除，因此采用int型的数组来保存路径，当到达叶子结点的时候，数组中的元素就是走过的路径，遍历数组拼成字符串</p><p>具体代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void preOrder(TreeNode* root, vector&lt;int&gt;&amp; path, vector&lt;string&gt;&amp; res) &#123;        path.push_back(root-&gt;val);&#x2F;&#x2F;注意，先把结点放进path中，树只有一个结点时，不会 把结点放进去        if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;            string temp &#x3D; &quot;&quot;;            for (int i &#x3D; 0; i &lt; path.size()-1; i++) &#123;&#x2F;&#x2F;注意范围                temp +&#x3D; to_string(path[i]);&#x2F;&#x2F;把数字转成字符串                temp +&#x3D; &quot;-&gt;&quot;;            &#125;            temp +&#x3D; to_string(path[path.size()-1]);&#x2F;&#x2F;因为最后一个不需要&quot;-&gt;&quot;            res.push_back(temp);            return;        &#125;        if (root-&gt;left) &#123;            preOrder(root-&gt;left, path, res);            path.pop_back();        &#125;        if (root-&gt;right) &#123;            preOrder(root-&gt;right, path, res);            path.pop_back();        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然也可以用迭代的方式（非递归）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;        stack&lt;TreeNode*&gt; treeSt;&#x2F;&#x2F; 保存树的遍历节点        stack&lt;string&gt; pathSt;   &#x2F;&#x2F; 保存遍历路径的节点        vector&lt;string&gt; result;  &#x2F;&#x2F; 保存最终路径集合        if (root &#x3D;&#x3D; NULL) return result;        treeSt.push(root);        pathSt.push(to_string(root-&gt;val));        while (!treeSt.empty()) &#123;            TreeNode* node &#x3D; treeSt.top(); treeSt.pop(); &#x2F;&#x2F; 取出节点 中            string path &#x3D; pathSt.top();pathSt.pop();    &#x2F;&#x2F; 取出该节点对应的路径            if (node-&gt;left &#x3D;&#x3D; NULL &amp;&amp; node-&gt;right &#x3D;&#x3D; NULL) &#123; &#x2F;&#x2F; 遇到叶子节点                result.push_back(path);            &#125;            if (node-&gt;right) &#123; &#x2F;&#x2F; 右                treeSt.push(node-&gt;right);                pathSt.push(path + &quot;-&gt;&quot; + to_string(node-&gt;right-&gt;val));&#x2F;&#x2F;注意            &#125;            if (node-&gt;left) &#123; &#x2F;&#x2F; 左                treeSt.push(node-&gt;left);                pathSt.push(path + &quot;-&gt;&quot; + to_string(node-&gt;left-&gt;val));&#x2F;&#x2F;注意            &#125;        &#125;        return result;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、路径总和"><a href="#3、路径总和" class="headerlink" title="3、路径总和"></a>3、路径总和</h2><p>示例: 给定如下二叉树，以及目标和 sum = 22</p><p><img src="https://img-blog.csdnimg.cn/20210203160355234.png" alt="112.路径总和1"></p><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p><p>迭代的话要把结点以及结点和存入栈</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool haspathsum(TreeNode* root, int sum) &#123;        if (root &#x3D;&#x3D; null) return false;        &#x2F;&#x2F; 此时栈里要放的是pair&lt;节点指针，路径数值&gt;        stack&lt;pair&lt;TreeNode*, int&gt;&gt; st;        st.push(pair&lt;TreeNode*, int&gt;(root, root-&gt;val));        while (!st.empty()) &#123;            pair&lt;TreeNode*, int&gt; node &#x3D; st.top();            st.pop();            &#x2F;&#x2F; 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true            if (!node.first-&gt;left &amp;&amp; !node.first-&gt;right &amp;&amp; sum &#x3D;&#x3D; node.second) return true;            &#x2F;&#x2F; 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来            if (node.first-&gt;right) &#123;                st.push(pair&lt;TreeNode*, int&gt;(node.first-&gt;right, node.second + node.first-&gt;right-&gt;val));            &#125;            &#x2F;&#x2F; 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来            if (node.first-&gt;left) &#123;                st.push(pair&lt;TreeNode*, int&gt;(node.first-&gt;left, node.second + node.first-&gt;left-&gt;val));            &#125;        &#125;        return false;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、根据中序和后序恢复二叉树"><a href="#4、根据中序和后序恢复二叉树" class="headerlink" title="4、根据中序和后序恢复二叉树"></a>4、根据中序和后序恢复二叉树</h2><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20221103150131216.png" alt="image-20221103150131216"></p><p>如果是手写的话当然容易，关键是怎么用代码实现，后序用来找根节点，中序用来分割左右，因此整个遍历构造二叉树的过程可以看做前序遍历；</p><p>如何分割数组呢？在传递的参数中加入数组的起点和终点下标，这样就可以分割数组；</p><p>注意数组的范围是左闭右开的;</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">TreeNode* myBuild(vector&lt;int&gt;&amp; inorder, int inleft, int inright, vector&lt;int&gt;&amp; postorder, int postleft, int postright) &#123;        if (postleft &#x3D;&#x3D; postright) return nullptr;&#x2F;&#x2F;空数组        int rootValue &#x3D; postorder[postright-1];        TreeNode *root &#x3D; new TreeNode(rootValue);        if (postright - postleft &#x3D;&#x3D; 1) return root;        int index;        for (index &#x3D; inleft; index &lt; inright; index++) &#123;            if (inorder[index] &#x3D;&#x3D; rootValue) break;        &#125;        root-&gt;left &#x3D; myBuild(inorder, inleft, index, postorder, postleft, postleft+index-inleft);        root-&gt;right &#x3D; myBuild(inorder, index+1, inright, postorder, postleft+index-inleft, postright-1);&#x2F;&#x2F;注意这里是减一        return root;    &#125;    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;        if (inorder.size() &#x3D;&#x3D; 0 || postorder.size() &#x3D;&#x3D; 0) return nullptr;        return myBuild(inorder, 0, inorder.size(), postorder, 0, postorder.size());    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、最大二叉树"><a href="#5、最大二叉树" class="headerlink" title="5、最大二叉树"></a>5、最大二叉树</h2><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20221103153629855.png" alt="image-20221103153629855"></p><p>类似于根据中序和后序构建二叉树，也是要通过数组下标分割数组，就是要注意一些细节的地方</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">TreeNode* mybuild(vector&lt;int&gt;&amp; nums, int begin, int end) &#123;        if (begin &#x3D;&#x3D; end) return nullptr;&#x2F;&#x2F;这里不是等于0，因为每次分割的数组开始下标都不一样，这里当时写错了        int maxIndex &#x3D; begin;        for (int i &#x3D; begin+1; i &lt; end; i++) &#123;&#x2F;&#x2F;还要注意i的起始下标            if (nums[maxIndex] &lt; nums[i]) maxIndex &#x3D; i;        &#125;        int rootValue &#x3D; nums[maxIndex];        TreeNode *root &#x3D; new TreeNode(rootValue);        if (end - begin &#x3D;&#x3D; 1) return root;        root-&gt;left &#x3D; mybuild(nums, begin, maxIndex);        root-&gt;right &#x3D; mybuild(nums, maxIndex+1, end);        return root;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6、验证二叉搜索树"><a href="#6、验证二叉搜索树" class="headerlink" title="6、验证二叉搜索树"></a>6、验证二叉搜索树</h2><p>如何判断一棵树是不是二叉搜索树呢？首先，二叉搜索树成立的条件：</p><p>1、左子树所有结点都小于根，右子树所有结点都大于根；</p><p>2、空树也是一棵二叉搜索树</p><p>这里尤其要注意第一点，刚开始的时候容易觉得根结点大于左边小于右边的结点就行，但是这是错的，比如下面一张图：</p><p><img src="https://img-blog.csdnimg.cn/20200812191501419.png" alt="二叉搜索树"></p><p>这显然不是一棵二叉搜索树！</p><p>因此可以采取中序遍历的方式，判断结点是不是递增的，如果不是则立马返回false；</p><p>（bool型的递归要知道，只要找到符合条件的就立马返回，这里的条件是不符合递增，就立马返回false）</p><p>（二叉搜索树一般都是采用<strong>中序遍历</strong>的方式来做的！！！）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">TreeNode *pre &#x3D; nullptr;    bool isValidBST(TreeNode* root) &#123;        &#x2F;&#x2F;二叉搜索树就是中序遍历，在遍历过程中是从小到大的话就是true，否则false；        if (!root) return true;        bool l &#x3D; isValidBST(root-&gt;left);        if (pre &amp;&amp; pre-&gt;val &gt;&#x3D; root-&gt;val) return false;        pre &#x3D; root;&#x2F;&#x2F;标记刚访问的结点作为之前的结点        bool r &#x3D; isValidBST(root-&gt;right);        return l &amp;&amp; r;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7、二叉树的最近公共祖先"><a href="#7、二叉树的最近公共祖先" class="headerlink" title="7、二叉树的最近公共祖先"></a>7、二叉树的最近公共祖先</h2><p>这里需要自底向上的方式遍历，如何自底向上呢？那就是回溯了，而且后序遍历是标准的回溯，因此采用后序遍历的框架，这里就要讨论需不需要返回值了，肯定是需要的，因为我们要 返回找到的公共结点，既然需要返回值，所以我们需要两个变量来接住每次遍历产生的返回值，然后做出逻辑判断</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        if (root &#x3D;&#x3D; q || root &#x3D;&#x3D; p || root &#x3D;&#x3D; NULL) return root;            TreeNode* left &#x3D; lowestCommonAncestor(root-&gt;left, p, q);        TreeNode* right &#x3D; lowestCommonAncestor(root-&gt;right, p, q);            if (left !&#x3D; NULL &amp;&amp; right !&#x3D; NULL) return root;        if (left &#x3D;&#x3D; NULL &amp;&amp; right !&#x3D; NULL) return right;        else if (left !&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL) return left;        else  &#123; &#x2F;&#x2F;  (left &#x3D;&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL)            return NULL;        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下图是遍历过程：</p><p><img src="https://img-blog.csdnimg.cn/202102041512582.png" alt="236.二叉树的最近公共祖先2"></p><p><strong>当然也可以采用深度优先遍历，逻辑也很简单，每次遍历的时候记录结点值以及对应的父节点（用哈希表）,然后再自底向上从p点开始遍历，把从p到根结点的路径上走过的每个结点都设为true，再从q自底向上遍历，如果遇到已经访问的点，那一定是最近的。</strong></p><h2 id="8、二叉搜索树中的插入操作"><a href="#8、二叉搜索树中的插入操作" class="headerlink" title="8、二叉搜索树中的插入操作"></a>8、二叉搜索树中的插入操作</h2><p>这道题不难，难的是怎么递归；自顶向下遍历二叉搜索树，往合适的方向遍历，当走到空节点说明找到了插入位置（也就是结束条件）；</p><p>究竟有没有返回值呢，最好有，因为我们要插入结点，也就是要创建一个新的结点，当走到插入的位置我们就可以返回这个新的结点，让变量接住就行，就算没有走到插入位置，我们也会返回结点本身，这样就不会改变二叉树的结构了；</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">TreeNode* insertIntoBST(TreeNode* root, int val) &#123;        if (!root) &#123;            TreeNode *node &#x3D; new TreeNode(val);            return node;        &#125;        if (root-&gt;val &gt; val) root-&gt;left &#x3D; insertIntoBST(root-&gt;left, val);        if (root-&gt;val &lt; val) root-&gt;right &#x3D; insertIntoBST(root-&gt;right, val);;        return root;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9、二叉搜索树的删除操作"><a href="#9、二叉搜索树的删除操作" class="headerlink" title="9、二叉搜索树的删除操作"></a>9、二叉搜索树的删除操作</h2><p><img src="https://img-blog.csdnimg.cn/20201020171048265.png" alt="450.删除二叉搜索树中的节点"></p><p>我们可以通过返回值插入结点，也可以通过返回值删除结点;</p><p>删除结点可能遇到的五种情况：</p><ul><li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li><li>找到删除的节点<ul><li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li><li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li><li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li><li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li></ul></li></ul><p>第五种情况有点难理解，看下图：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbj3k596mg30dq0aigyz.gif" alt="450.删除二叉搜索树中的节点"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">TreeNode* deleteNode(TreeNode* root, int key) &#123;        if (root &#x3D;&#x3D; nullptr) return root; &#x2F;&#x2F; 第一种情况：没找到删除的节点，遍历到空节点直接返回了        if (root-&gt;val &#x3D;&#x3D; key) &#123;            &#x2F;&#x2F; 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点            if (root-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; root-&gt;right &#x3D;&#x3D; nullptr) &#123;                &#x2F;&#x2F;&#x2F;! 内存释放                delete root;                return nullptr;            &#125;            &#x2F;&#x2F; 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点            else if (root-&gt;left &#x3D;&#x3D; nullptr) &#123;                auto retNode &#x3D; root-&gt;right;                &#x2F;&#x2F;&#x2F;! 内存释放                delete root;                return retNode;            &#125;            &#x2F;&#x2F; 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点            else if (root-&gt;right &#x3D;&#x3D; nullptr) &#123;                auto retNode &#x3D; root-&gt;left;                &#x2F;&#x2F;&#x2F;! 内存释放                delete root;                return retNode;            &#125;            &#x2F;&#x2F; 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置            &#x2F;&#x2F; 并返回删除节点右孩子为新的根节点。            else &#123;                TreeNode* cur &#x3D; root-&gt;right; &#x2F;&#x2F; 找右子树最左面的节点                while(cur-&gt;left !&#x3D; nullptr) &#123;                    cur &#x3D; cur-&gt;left;                &#125;                cur-&gt;left &#x3D; root-&gt;left; &#x2F;&#x2F; 把要删除的节点（root）左子树放在cur的左孩子的位置                TreeNode* tmp &#x3D; root;   &#x2F;&#x2F; 把root节点保存一下，下面来删除                root &#x3D; root-&gt;right;     &#x2F;&#x2F; 返回旧root的右孩子作为新root                delete tmp;             &#x2F;&#x2F; 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）                return root;            &#125;        &#125;        if (root-&gt;val &gt; key) root-&gt;left &#x3D; deleteNode(root-&gt;left, key);        if (root-&gt;val &lt; key) root-&gt;right &#x3D; deleteNode(root-&gt;right, key);        return root;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10、修剪二叉树"><a href="#10、修剪二叉树" class="headerlink" title="10、修剪二叉树"></a>10、修剪二叉树</h2><p>给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p><p><img src="https://img-blog.csdnimg.cn/20201014173115788.png" alt="669.修剪二叉搜索树"></p><p>这道题与之前的删除和插入操作不同的是，如果当前结点不符合条件，那么它的左子树或者右子树一定也不符合条件，所以只要返回它的左子树或者右子树再接住就行</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">TreeNode* trimBST(TreeNode* root, int low, int high) &#123;        if (!root) return nullptr;        if (root-&gt;val &lt; low) &#123;&#x2F;&#x2F;如果当前值比low还小，说明左边也不符合条件一起删掉（包括自己），返回右节点            return trimBST(root-&gt;right, low, high);        &#125;        if (root-&gt;val &gt; high) &#123;&#x2F;&#x2F;如果当前值比high还大，说明右边也不符合，返回左节点            return trimBST(root-&gt;left, low, high);        &#125;        root-&gt;left &#x3D; trimBST(root-&gt;left, low, high);        root-&gt;right &#x3D; trimBST(root-&gt;right, low, high);        return root;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非递归方法，先把root移到符合范围的结点上再开始操作</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">TreeNode* trimBST(TreeNode* root, int L, int R) &#123;        if (!root) return nullptr;        &#x2F;&#x2F; 处理头结点，让root移动到[L, R] 范围内，注意是左闭右闭        while (root !&#x3D; nullptr &amp;&amp; (root-&gt;val &lt; L || root-&gt;val &gt; R)) &#123;            if (root-&gt;val &lt; L) root &#x3D; root-&gt;right; &#x2F;&#x2F; 小于L往右走            else root &#x3D; root-&gt;left; &#x2F;&#x2F; 大于R往左走        &#125;        TreeNode *cur &#x3D; root;        &#x2F;&#x2F; 此时root已经在[L, R] 范围内，处理左孩子元素小于L的情况        while (cur !&#x3D; nullptr) &#123;            while (cur-&gt;left &amp;&amp; cur-&gt;left-&gt;val &lt; L) &#123;                cur-&gt;left &#x3D; cur-&gt;left-&gt;right;            &#125;            cur &#x3D; cur-&gt;left;        &#125;        cur &#x3D; root;        &#x2F;&#x2F; 此时root已经在[L, R] 范围内，处理右孩子大于R的情况        while (cur !&#x3D; nullptr) &#123;            while (cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val &gt; R) &#123;                cur-&gt;right &#x3D; cur-&gt;right-&gt;left;            &#125;            cur &#x3D; cur-&gt;right;        &#125;        return root;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11、将有序数组转化为二叉搜索树"><a href="#11、将有序数组转化为二叉搜索树" class="headerlink" title="11、将有序数组转化为二叉搜索树"></a>11、将有序数组转化为二叉搜索树</h2><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p>示例:</p><p><img src="https://img-blog.csdnimg.cn/20201022164420763.png" alt="108.将有序数组转换为二叉搜索树"></p><p>前面做过通过中序和后序建立二叉树的题，这道题也差不多，关键是要确保是平衡树，因此树的根节点必须从数组的中间结点选择，然后再同过递归以及数组分割来构建二叉树</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">TreeNode* mybuild(vector&lt;int&gt;&amp; nums, int begin, int end) &#123;        if (begin &#x3D;&#x3D; end) return nullptr;        int mid &#x3D; begin + (end - begin) &#x2F; 2;        int rootValue &#x3D; nums[mid];        TreeNode *root &#x3D; new TreeNode(rootValue);        if (end - begin &#x3D;&#x3D; 1) return root;        root-&gt;left &#x3D; mybuild(nums, begin, mid);        root-&gt;right &#x3D; mybuild(nums, mid+1, end);        return root;    &#125;    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        if (nums.size() &#x3D;&#x3D; 0) return nullptr;        return mybuild(nums, 0 ,nums.size());    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二叉树递归遍历总结："><a href="#二叉树递归遍历总结：" class="headerlink" title="二叉树递归遍历总结："></a>二叉树递归遍历总结：</h1><p>1、什么时候有返回值？什么时候没有返回值？</p><p>只要找到一条路径或者一个结点的时候需要返回值，此时立刻返回；</p><p>当要遍历整棵树的时候，一般没有返回值；</p><p>当然也有特殊情况：</p><p>以后序遍历为例，有返回值的写法：</p><p>当搜索一条边时：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (递归函数(root-&gt;left)) return;if (递归函数(root-&gt;right)) return;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当遍历整棵树时：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">left &#x3D; 递归函数(root-&gt;left);right &#x3D; 递归函数(root-&gt;right);left与right的逻辑处理<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、求二叉树的最小深度&quot;&gt;&lt;a href=&quot;#1、求二叉树的最小深度&quot; class=&quot;headerlink&quot; title=&quot;1、求二叉树的最小深度&quot;&gt;&lt;/a&gt;1、求二叉树的最小深度&lt;/h2&gt;&lt;p&gt;与求二叉树最大深度不一样，如果直接像求二叉树最大深度那样递归求二叉树</summary>
      
    
    
    
    <category term="算法" scheme="http://fhc20001118.github.io/project/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二叉树" scheme="http://fhc20001118.github.io/project/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>双指针刷题笔记</title>
    <link href="http://fhc20001118.github.io/project/2022/11/28/%E5%8F%8C%E6%8C%87%E9%92%88%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://fhc20001118.github.io/project/2022/11/28/%E5%8F%8C%E6%8C%87%E9%92%88%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2022-11-27T16:00:00.000Z</published>
    <updated>2022-12-16T03:30:31.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、三数之和"><a href="#1、三数之和" class="headerlink" title="1、三数之和"></a>1、三数之和</h2><p><strong>注意：使用双指针一定要记得排序！！！</strong></p><p>​    1）如何遍历？</p><p>​    先排序，a = nums[i], b = nums[left], c = nums[right]</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;            &#x2F;&#x2F; 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了            if (nums[i] &gt; 0) &#123;                return result;            &#125;            &#x2F;&#x2F; 错误去重a方法，将会漏掉-1,-1,2 这种情况            &#x2F;*            if (nums[i] &#x3D;&#x3D; nums[i + 1]) &#123;                continue;            &#125;            *&#x2F;            &#x2F;&#x2F; 正确去重a方法            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;                continue;            &#125;            int left &#x3D; i + 1;            int right &#x3D; nums.size() - 1;            while (right &gt; left) &#123;                &#x2F;&#x2F; 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;&#x3D;left 了，从而漏掉了    0,0,0 这种三元组                &#x2F;*                while (right &gt; left &amp;&amp; nums[right] &#x3D;&#x3D; nums[right - 1]) right--;                while (right &gt; left &amp;&amp; nums[left] &#x3D;&#x3D; nums[left + 1]) left++;                *&#x2F;                if (nums[i] + nums[left] + nums[right] &gt; 0) right--;                else if (nums[i] + nums[left] + nums[right] &lt; 0) left++;                else &#123;result.push_back(vector&lt;int&gt;&#123;nums[i], nums[left], nums[right]&#125;);                    &#x2F;&#x2F; 去重逻辑应该放在找到一个三元组之后，对b 和 c去重                    while (right &gt; left &amp;&amp; nums[right] &#x3D;&#x3D; nums[right - 1]) right--;                    while (right &gt; left &amp;&amp; nums[left] &#x3D;&#x3D; nums[left + 1]) left++;                    &#x2F;&#x2F; 找到答案时，双指针同时收缩                    right--;                    left++;                &#125;            &#125;        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    2）如何去重？</p><p>​    参考上面一段代码</p><h2 id="2、四数之和"><a href="#2、四数之和" class="headerlink" title="2、四数之和"></a>2、四数之和</h2><p>相当于在三数之和的基础上加了一层循环，确定第一个数字就变成了三数之和</p><p>有趣的是这里的去重以及剪枝优化</p><p>例如： 不要判断<code>nums[k] &gt; target</code> 就返回了，三数之和 可以通过 <code>nums[i] &gt; 0</code> 就返回了，因为 0 已经是确定的数了，四数之和这道题目 target是任意值。比如：数组是<code>[-4, -3, -2, -1]</code>，<code>target</code>是<code>-10</code>，不能因为<code>-4 &gt; -10</code>而跳过（因为如果为负数，数值越大就越小）。但是我们依旧可以去做剪枝，逻辑变成<code>nums[i] &gt; target &amp;&amp; (nums[i] &gt;=0 || target &gt;= 0)</code>就可以了。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;        sort(nums.begin(), nums.end());        vector&lt;vector&lt;int&gt;&gt;res;        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;            &#x2F;&#x2F;注意target不一定是0或者正数            if (nums[i] &gt; target &amp;&amp; nums[i] &gt;&#x3D; 0) break;            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i-1]) continue;                        for (int j &#x3D; i+1; j &lt; nums.size(); j++) &#123;                if (nums[i] + nums[j] &gt; target &amp;&amp; nums[i] + nums[j] &gt;&#x3D; 0) break;                &#x2F;&#x2F;b去重                if (j &gt; i+1 &amp;&amp; nums[j] &#x3D;&#x3D; nums[j-1]) continue;                int left &#x3D; j+1;                int right &#x3D; nums.size()-1;                while (left &lt; right) &#123;                    if ((long)nums[i] + nums[j] + nums[left] + nums[right] &gt; target) right--;                    else if ((long)nums[i] + nums[j] + nums[left] + nums[right] &lt; target) left++;                    else &#123;                        res.push_back(&#123;nums[i], nums[j], nums[left], nums[right]&#125;);                        while (left &lt; right &amp;&amp; nums[left] &#x3D;&#x3D; nums[left+1]) left++;                        while (left &lt; right &amp;&amp; nums[right] &#x3D;&#x3D; nums[right-1]) right--;                        left++;                        right--;                    &#125;                &#125;            &#125;        &#125;        return res;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、三数之和&quot;&gt;&lt;a href=&quot;#1、三数之和&quot; class=&quot;headerlink&quot; title=&quot;1、三数之和&quot;&gt;&lt;/a&gt;1、三数之和&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;注意：使用双指针一定要记得排序！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    1）如何遍历</summary>
      
    
    
    
    <category term="算法" scheme="http://fhc20001118.github.io/project/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="双指针" scheme="http://fhc20001118.github.io/project/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>哈希表刷题笔记</title>
    <link href="http://fhc20001118.github.io/project/2022/11/28/%E5%93%88%E5%B8%8C%E8%A1%A8%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://fhc20001118.github.io/project/2022/11/28/%E5%93%88%E5%B8%8C%E8%A1%A8%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2022-11-27T16:00:00.000Z</published>
    <updated>2022-12-16T03:29:25.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、字符串中的字符出现次数（都是小写的情况下）"><a href="#1、字符串中的字符出现次数（都是小写的情况下）" class="headerlink" title="1、字符串中的字符出现次数（都是小写的情况下）"></a>1、字符串中的字符出现次数（都是小写的情况下）</h2><p>因为字母一共26个，所以可以定义一个长度为26的数组来记录每个字符出现的次数;</p><p>字母a的下标为 ‘a’ - ‘a’ = 0；字母z的下标为 ‘z’ - ‘a’ = 25；</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt;record(26);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、两数之和如何使用哈希表"><a href="#2、两数之和如何使用哈希表" class="headerlink" title="2、两数之和如何使用哈希表"></a>2、两数之和如何使用哈希表</h2><p>如果在初始化哈希表的时候是直接把nums中的每个元素以及它对应的下标放入哈希表中，当遇到相同的元素时候就不会重复放入，这样就会导致答案出错，因为可能两个相同的数刚好能构成这个target，因此在初始化的时候要判断是否在哈希表中能找到一个数加上当前遍历到的这个数的和等于target，如果可以的话就返回，不可以的话再把这个数和它的下标存入哈希表中</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;           if (index.find(target - nums[i]) &#x3D;&#x3D; index.end()) &#123;               index[nums[i]] &#x3D; i;           &#125;           else &#123;               res[0] &#x3D; i;               res[1] &#x3D; index[target - nums[i]];               return res;           &#125;       &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、四数相加II"><a href="#3、四数相加II" class="headerlink" title="3、四数相加II"></a>3、四数相加II</h2><p><img src="https://raw.githubusercontent.com/fhc20001118/images/master/img/image-20221101192105059.png" alt="image-20221101192105059"></p><p>这道题比三数之和和四数之和简单，因为它不考虑重复；</p><p>解决办法：</p><p>双循环遍历nums1和nums2并计算他们两两的和作为哈希表的key值，value是他们出现的次数；</p><p>然后双循环遍历nums3和nums4并计算0减他们两两的和，在哈希表中查找是否存在，若存在则count统计他们的value（出现的次数就是能够构成元组的次数）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">unordered_map&lt;int, int&gt;mp;        int count &#x3D; 0;        for (int num1 : nums1) &#123;            for (int num2 : nums2) &#123;                mp[num1+num2]++;            &#125;        &#125;        for (int num3 : nums3) &#123;            for (int num4 : nums4) &#123;                if (mp.find(0-(num3+num4)) !&#x3D; mp.end()) &#123;                    count +&#x3D; mp[0-(num3+num4)];                &#125;            &#125;        &#125;        return count;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、字符串中的字符出现次数（都是小写的情况下）&quot;&gt;&lt;a href=&quot;#1、字符串中的字符出现次数（都是小写的情况下）&quot; class=&quot;headerlink&quot; title=&quot;1、字符串中的字符出现次数（都是小写的情况下）&quot;&gt;&lt;/a&gt;1、字符串中的字符出现次数（都是小</summary>
      
    
    
    
    <category term="算法" scheme="http://fhc20001118.github.io/project/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="哈希表" scheme="http://fhc20001118.github.io/project/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口刷题笔记</title>
    <link href="http://fhc20001118.github.io/project/2022/11/28/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://fhc20001118.github.io/project/2022/11/28/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2022-11-27T16:00:00.000Z</published>
    <updated>2022-12-16T03:31:13.208Z</updated>
    
    <content type="html"><![CDATA[<p>一般用来解决<strong>连续的子数组或者字串</strong>的问题</p><p>滑动窗口模板：</p><p>注意是<strong>左闭右开</strong>的区间！！！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int left &#x3D; 0, right &#x3D; 0;        while (right &lt; s.size()) &#123;            &#x2F;&#x2F;增大窗口            window.add(s[right]);            right++;            while (window needs shrink) &#123;                &#x2F;&#x2F;缩小窗口                window.remove(s[left]);                left++;            &#125;        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>滑动窗口框架（找最小字串）：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void slidingWindow(string s, string t) &#123;    unordered_map&lt;char, int&gt;need, window;    for (char ch : t) need[ch]++;        int left &#x3D; 0, right &#x3D; 0;    int valid &#x3D; 0;&#x2F;&#x2F;表示窗口中满足need条件的有效字符个数，如果valid和need.size大小相同， 则说明窗口已满足条件    while (right &lt; s.size()) &#123;        &#x2F;&#x2F;ch是将移入窗口的字符        char ch &#x3D; s[right];        &#x2F;&#x2F;右移窗口        right++;        &#x2F;&#x2F;进行窗口内数据的一系列更新        &#x2F;*......*&#x2F;                &#x2F;&#x2F;debug输出的位置printf(&quot;window: [%d, &amp;d)\n&quot;, left, right);                &#x2F;&#x2F;满足条件开始收缩        while (window needs shrink) &#123;            &#x2F;&#x2F;d是将移出窗口的字符char d &#x3D; s[left];            &#x2F;&#x2F;左移窗口            left++;            &#x2F;&#x2F;进行窗口内的一系列数据的更新            &#x2F;*......*&#x2F;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>滑动窗口框架（找最大子串）：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int totalFruit(vector&lt;int&gt;&amp; fruits) &#123;        unordered_map&lt;int, int&gt;window;        int left &#x3D; 0, right &#x3D; 0;        int len &#x3D; INT_MIN;        int valid &#x3D; 0;        while (right &lt; fruits.size()) &#123;            int n &#x3D; fruits[right];            right++;            window[n]++;            if (window[n] &#x3D;&#x3D; 1) valid++;                        &#x2F;&#x2F;printf(&quot;window[%d, %d)     valid:%d\n&quot;, left, right, valid);            &#x2F;&#x2F;如果window中的数字满足条件并且长度更大，就更新            if (valid &lt;&#x3D; 2 &amp;&amp; right - left &gt; len) &#123;                len &#x3D; right - left;            &#125;            &#x2F;&#x2F;直到window扩大到不满足条件才开始缩小                while (valid &gt; 2) &#123;                    int m &#x3D; fruits[left];                    left++;                    window[m]--;                    if (!window[m]) valid--;                    &#x2F;&#x2F;printf(&quot;window[%d, %d)     valid:%d\n&quot;, left, right, valid);                &#125;        &#125;        return len;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一般用来解决&lt;strong&gt;连续的子数组或者字串&lt;/strong&gt;的问题&lt;/p&gt;
&lt;p&gt;滑动窗口模板：&lt;/p&gt;
&lt;p&gt;注意是&lt;strong&gt;左闭右开&lt;/strong&gt;的区间！！！&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-c++&quot; data</summary>
      
    
    
    
    <category term="算法" scheme="http://fhc20001118.github.io/project/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="滑动窗口" scheme="http://fhc20001118.github.io/project/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>字符串数组刷题笔记</title>
    <link href="http://fhc20001118.github.io/project/2022/11/28/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://fhc20001118.github.io/project/2022/11/28/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2022-11-27T16:00:00.000Z</published>
    <updated>2022-12-16T09:30:19.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、字符串数组模板"><a href="#一、字符串数组模板" class="headerlink" title="一、字符串数组模板"></a>一、字符串数组模板</h1><p>思路：把句子中所有字符串取出放入字符串数组，再对数组中的字符串进行操作后重新连接即可，具体细节根据具体问题具体分析；</p><p>遍历句子取字符串的思路，就是遇到字符把它放入临时字符串，遇到空格或者标点，就把临时字符串输出并且清空。</p><p>1、如果有前、后置空格，那么必须判断临时字符串非空才能输出</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">s +&#x3D; &#39; &#39;;&#x2F;&#x2F;在最后一个字符位置加上空格，这样最后一个字符就不会遗漏string temp &#x3D; &quot;&quot;;&#x2F;&#x2F;临时字符串vector&lt;string&gt; res;&#x2F;&#x2F;存放字符串的数组for (char ch : s) &#123;    &#x2F;&#x2F;遇到空格    if (ch &#x3D;&#x3D; &quot; &quot;) &#123;        if (!temp.empty()) &#123;            res.push_back(temp);            temp.clear();&#125;    &#125;    else &#123;        temp +&#x3D; ch;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、没有前、后置空格不需要判断是否temp为空</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">s +&#x3D; &quot; &quot;;string temp &#x3D; &quot;&quot;;vector&lt;string&gt;res;for (char ch : s) &#123;    if (ch &#x3D;&#x3D; &quot; &quot;) &#123;        res.push_back(temp);        temp.clear();    &#125;    else &#123;        temp +&#x3D; ch;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如翻转单词就可以用这个模板</p><h1 id="二、反转字符串II"><a href="#二、反转字符串II" class="headerlink" title="二、反转字符串II"></a>二、反转字符串II</h1><p>这道题不难，主要是找到reverse的开始和结尾就行</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;注意reverse的结尾是到前一个数reverse(s.begin(), s.end());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20221030185141264.png" alt="image-20221030185141264"></p><p>这是自己写出来的：（没有技巧）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string reverseStr(string s, int k) &#123;        &#x2F;&#x2F;reverse(s.begin()+0+1, s.begin()+0+k-1);        &#x2F;&#x2F;reverse(s.begin(),s.end());        &#x2F;&#x2F;reverse(s.begin(), s.begin()+k);        int count &#x3D; 0;        int start &#x3D; 0;        for (int i &#x3D; 0; i &lt; s.size(); i++) &#123;            count++;            &#x2F;&#x2F;cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; count &lt;&lt; endl;            if (count &#x3D;&#x3D; 2 * k) &#123;                &#x2F;&#x2F;cout &lt;&lt; count;                &#x2F;&#x2F;反转前k个字符                reverse(s.begin()+start, s.begin()+start+k);                start &#x3D; start+count;                count &#x3D; 0;            &#125;            &#x2F;&#x2F;剩余字符小于k个            else if (count &lt; k &amp;&amp; i+1 &#x3D;&#x3D; s.size()) &#123;                reverse(s.begin()+start, s.end());            &#125;            else if ((count &lt; (2*k) &amp;&amp; count &gt;&#x3D; k) &amp;&amp; i+1 &#x3D;&#x3D; s.size()) &#123;                reverse(s.begin()+start, s.begin()+start+k);            &#125;                    &#125;        return s;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是用了技巧的，直接每次走2k步，然后开始反转</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string reverseStr(string s, int k) &#123;        for (int i &#x3D; 0; i &lt; s.size(); i +&#x3D; (2 * k)) &#123;            &#x2F;&#x2F; 1. 每隔 2k 个字符的前 k 个字符进行反转            &#x2F;&#x2F; 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符            if (i + k &lt;&#x3D; s.size()) &#123;                reverse(s.begin() + i, s.begin() + i + k );            &#125; else &#123;                &#x2F;&#x2F; 3. 剩余字符少于 k 个，则将剩余字符全部反转。                reverse(s.begin() + i, s.end());            &#125;        &#125;        return s;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、KMP算法思想"><a href="#三、KMP算法思想" class="headerlink" title="三、KMP算法思想"></a>三、KMP算法思想</h1><h2 id="1）什么是KMP？"><a href="#1）什么是KMP？" class="headerlink" title="1）什么是KMP？"></a>1）什么是KMP？</h2><p>说到KMP，先说一下KMP这个名字是怎么来的，为什么叫做KMP呢。</p><p>因为是由这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做KMP</p><h2 id="2）KMP有什么用"><a href="#2）KMP有什么用" class="headerlink" title="2）KMP有什么用"></a>2）KMP有什么用</h2><p>KMP主要应用在字符串匹配上。</p><p>KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p><p>所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。</p><p>其实KMP的代码不好理解，一些同学甚至直接把KMP代码的模板背下来。</p><p>没有彻底搞懂，懵懵懂懂就把代码背下来太容易忘了。</p><p>不仅面试的时候可能写不出来，如果面试官问：<strong>next数组里的数字表示的是什么，为什么这么表示？</strong></p><p>估计大多数候选人都是懵逼的。</p><h2 id="3）什么是前缀表"><a href="#3）什么是前缀表" class="headerlink" title="3）什么是前缀表"></a>3）什么是前缀表</h2><p>写过KMP的同学，一定都写过next数组，那么这个next数组究竟是个啥呢？</p><p>next数组就是一个前缀表（prefix table）。</p><p>前缀表有什么作用呢？</p><p><strong>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</strong></p><p>为了清楚的了解前缀表的来历，我们来举一个例子：</p><p>要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</p><p>请记住文本串和模式串的作用，对于理解下文很重要，要不然容易看懵。所以说三遍：</p><p>要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</p><p>要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</p><p>要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</p><p>如动画所示：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif" alt="KMP详解1"></p><p>动画里，我特意把 子串<code>aa</code> 标记上了，这是有原因的，大家先注意一下，后面还会说道。</p><p>可以看出，文本串中第六个字符b 和 模式串的第六个字符f，不匹配了。如果暴力匹配，会发现不匹配，此时就要从头匹配了。</p><p>但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中第三个字符b继续开始匹配。</p><p>此时就要问了<strong>前缀表是如何记录的呢？</strong></p><p>首先要知道前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。</p><p>那么什么是前缀表：<strong>记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</strong></p><h2 id="5）最长公共前后缀？"><a href="#5）最长公共前后缀？" class="headerlink" title="5）最长公共前后缀？"></a>5）最长公共前后缀？</h2><p>文章中字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>。</p><p><strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。</p><p><strong>正确理解什么是前缀什么是后缀很重要</strong>!</p><p>那么网上清一色都说 “kmp 最长公共前后缀” 又是什么回事呢？</p><p>我查了一遍 算法导论 和 算法4里KMP的章节，都没有提到 “最长公共前后缀”这个词，也不知道从哪里来了，我理解是用“最长相等前后缀” 更准确一些。</p><p><strong>因为前缀表要求的就是相同前后缀的长度。</strong></p><p>而最长公共前后缀里面的“公共”，更像是说前缀和后缀公共的长度。这其实并不是前缀表所需要的。</p><p>所以字符串a的最长相等前后缀为0。 字符串aa的最长相等前后缀为1。 字符串aaa的最长相等前后缀为2。 等等…..。</p><h2 id="6）为什么一定要用前缀表"><a href="#6）为什么一定要用前缀表" class="headerlink" title="6）为什么一定要用前缀表"></a>6）为什么一定要用前缀表</h2><p>这就是前缀表，那为啥就能告诉我们 上次匹配的位置，并跳过去呢？</p><p>回顾一下，刚刚匹配的过程在下标5的地方遇到不匹配，模式串是指向f，如图：</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B21.png" alt="KMP精讲1"></p><p>然后就找到了下标2，指向b，继续匹配：如图：</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B22.png" alt="KMP精讲2"></p><p>以下这句话，对于理解为什么使用前缀表可以告诉我们匹配失败之后跳到哪里重新匹配 非常重要！</p><p><strong>下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面从新匹配就可以了。</strong></p><p>所以前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。</p><p><strong>很多介绍KMP的文章或者视频并没有把为什么要用前缀表这个问题说清楚，而是直接默认使用前缀表。</strong></p><h2 id="7）如何计算前缀表"><a href="#7）如何计算前缀表" class="headerlink" title="7）如何计算前缀表"></a>7）如何计算前缀表</h2><p>接下来就要说一说怎么计算前缀表。</p><p>如图：</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B25.png" alt="KMP精讲5"></p><p>长度为前1个字符的子串<code>a</code>，最长相同前后缀的长度为0。（注意字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>；<strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。）</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B26.png" alt="KMP精讲6"></p><p>长度为前2个字符的子串 aa，最长相同前后缀的长度为1。</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B27.png" alt="KMP精讲7"></p><p>长度为前3个字符的子串 aab，最长相同前后缀的长度为0。</p><p>以此类推： 长度为前4个字符的子串<code>aaba</code>，最长相同前后缀的长度为1。 长度为前5个字符的子串<code>aabaa</code>，最长相同前后缀的长度为2。 长度为前6个字符的子串<code>aabaaf</code>，最长相同前后缀的长度为0。</p><p>那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图：</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B28.png" alt="KMP精讲8"></p><p>可以看出模式串与前缀表对应位置的数字表示的就是：<strong>下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</strong></p><p>再来看一下如何利用 前缀表找到 当字符不匹配的时候应该指针应该移动的位置。如动画所示：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B22.gif" alt="KMP精讲2"></p><p>找到的不匹配的位置， 那么此时我们要看它的前一个字符的前缀表的数值是多少。</p><p>为什么要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀。</p><p>所以要看前一位的 前缀表的数值。</p><p>前一个字符的前缀表的数值是2， 所有把下标移动到下标2的位置继续比配。 可以再反复看一下上面的动画。</p><p>最后就在文本串中找到了和模式串匹配的子串了。</p><h1 id="8）前缀表与next数组"><a href="#8）前缀表与next数组" class="headerlink" title="8）前缀表与next数组"></a>8）前缀表与next数组</h1><p>很多KMP算法的时间都是使用next数组来做回退操作，那么next数组与前缀表有什么关系呢？</p><p>next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。</p><p>为什么这么做呢，其实也是很多文章视频没有解释清楚的地方。</p><p>其实<strong>这并不涉及到KMP的原理，而是具体实现，next数组即可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。</strong></p><p>后面我会提供两种不同的实现代码，大家就明白了。</p><h1 id="9）使用next数组来匹配"><a href="#9）使用next数组来匹配" class="headerlink" title="9）使用next数组来匹配"></a>9）使用next数组来匹配</h1><p><strong>以下我们以前缀表统一减一之后的next数组来做演示</strong>。</p><p>有了next数组，就可以根据next数组来 匹配文本串s，和模式串t了。</p><p>注意next数组是新前缀表（旧前缀表统一减一了）。</p><p>匹配过程动画如下：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B24.gif" alt="KMP精讲4"></p><h3 id="具体内容看代码随想录实现strStr（）字符串"><a href="#具体内容看代码随想录实现strStr（）字符串" class="headerlink" title="具体内容看代码随想录实现strStr（）字符串"></a>具体内容看代码随想录实现strStr（）字符串</h3><h2 id="next数组："><a href="#next数组：" class="headerlink" title="next数组："></a>next数组：</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void getNext(int* next, const string&amp; s)&#123;    int j &#x3D; -1;    next[0] &#x3D; j;    for(int i &#x3D; 1; i &lt; s.size(); i++) &#123; &#x2F;&#x2F; 注意i从1开始        while (j &gt;&#x3D; 0 &amp;&amp; s[i] !&#x3D; s[j + 1]) &#123; &#x2F;&#x2F; 前后缀不相同了            j &#x3D; next[j]; &#x2F;&#x2F; 向前回退        &#125;        if (s[i] &#x3D;&#x3D; s[j + 1]) &#123; &#x2F;&#x2F; 找到相同的前后缀            j++;        &#125;        next[i] &#x3D; j; &#x2F;&#x2F; 将j（前缀的长度）赋给next[i]    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码构造next数组的逻辑流程动画如下：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B23.gif" alt="KMP精讲3"></p><p>实现代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void getNext(int* next, const string&amp; s) &#123;        int j &#x3D; 0;        next[0] &#x3D; 0;        for(int i &#x3D; 1; i &lt; s.size(); i++) &#123;            while (j &gt; 0 &amp;&amp; s[i] !&#x3D; s[j]) &#123;                j &#x3D; next[j - 1];            &#125;            if (s[i] &#x3D;&#x3D; s[j]) &#123;                j++;            &#125;            next[i] &#x3D; j;        &#125;    &#125;    int strStr(string haystack, string needle) &#123;        if (needle.size() &#x3D;&#x3D; 0) &#123;            return 0;        &#125;        int next[needle.size()];        getNext(next, needle);        int j &#x3D; 0;        for (int i &#x3D; 0; i &lt; haystack.size(); i++) &#123;            while(j &gt; 0 &amp;&amp; haystack[i] !&#x3D; needle[j]) &#123;                j &#x3D; next[j - 1];            &#125;            if (haystack[i] &#x3D;&#x3D; needle[j]) &#123;                j++;            &#125;            if (j &#x3D;&#x3D; needle.size() ) &#123;                return (i - needle.size() + 1);            &#125;        &#125;        return -1;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、重复的字符串"><a href="#四、重复的字符串" class="headerlink" title="四、重复的字符串"></a>四、重复的字符串</h1><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><p>示例 1:<br>输入: “abab”<br>输出: True<br>解释: 可由子字符串 “ab” 重复两次构成。</p><p>示例 2:<br>输入: “aba”<br>输出: False</p><p>方法一：</p><p>​    如果判断字符串s是否由一个子串重复构成，可以将相同的两个s拼在一起，然后去掉首尾字符，在新的字符串中是否能找到s，若能，则返回true，若不能则返回false；</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool repeatedSubstringPattern(string s) &#123;        string t &#x3D; s + s;        t.erase(t.begin()); t.erase(t.end() - 1); &#x2F;&#x2F; 掐头去尾    &#x2F;&#x2F;std::string::npos表示一个不存在的位置，如果等于它说明找不到，不等于它，说明能找到        if (t.find(s) !&#x3D; std::string::npos) return true;         return false;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法二：</p><p>​    用KMP算法判断，最长相等前缀长度为next[len - 1]，数组长度为len，len - next[len - 1]是剩下的字符串长度，如果</p><p>len % (len - next[len - 1]) == 0，则说明有重复的字符串(具体推导看代码随想录字符串一章)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void getNext (int* next, const string&amp; s)&#123;        next[0] &#x3D; 0;        int j &#x3D; 0;        for(int i &#x3D; 1;i &lt; s.size(); i++)&#123;            while(j &gt; 0 &amp;&amp; s[i] !&#x3D; s[j]) &#123;                j &#x3D; next[j - 1];            &#125;            if(s[i] &#x3D;&#x3D; s[j]) &#123;                j++;            &#125;            next[i] &#x3D; j;        &#125;    &#125;    bool repeatedSubstringPattern (string s) &#123;        if (s.size() &#x3D;&#x3D; 0) &#123;            return false;        &#125;        int next[s.size()];        getNext(next, s);        int len &#x3D; s.size();        &#x2F;&#x2F;next[len - 1] !&#x3D; 0说明存在公共前后缀,如果不存在就不用比较了，肯定不能由重复串构成        if (next[len - 1] !&#x3D; 0 &amp;&amp; len % (len - (next[len - 1] )) &#x3D;&#x3D; 0) &#123;            return true;        &#125;        return false;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="字符串一些操作总结："><a href="#字符串一些操作总结：" class="headerlink" title="字符串一些操作总结："></a>字符串一些操作总结：</h1><h2 id="1、字符串比较："><a href="#1、字符串比较：" class="headerlink" title="1、字符串比较："></a>1、字符串比较：</h2><p>strcmp(str1, str2)         相同返回false，不同返回true</p><h2 id="2、字符串截取子串substr"><a href="#2、字符串截取子串substr" class="headerlink" title="2、字符串截取子串substr()"></a>2、字符串截取子串substr()</h2><p>substr() 函数可以提取 string 字符串中的子字符串，该函数有两个参数，第一个参数为需要提取的子字符串的起始下标，第二个参数是需要提取的子字符串的长度。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123;    string s1 &#x3D; &quot;first second third&quot;;    string s2;    s2 &#x3D; s1.substr(6, 6);    cout&lt;&lt; s1 &lt;&lt;endl;    cout&lt;&lt; s2 &lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">first second thirdsecond<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3、字符串的find-函数"><a href="#3、字符串的find-函数" class="headerlink" title="3、字符串的find() 函数"></a>3、字符串的find() 函数</h2><p>find() 函数可以在字符串中查找子字符串中出现的位置。该函数有两个参数，第一个参数是待查找的子字符串，第二个参数是表示开始查找的位置，如果第二个参数不指名的话则默认从 0 开始查找，也即从字符串首开始查找。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123;    string s1 &#x3D; &quot;first second third&quot;;    string s2 &#x3D; &quot;second&quot;;    int index &#x3D; s1.find(s2,5);    if(index &lt; s1.length())        cout&lt;&lt;&quot;Found at index : &quot;&lt;&lt; index &lt;&lt;endl;    else        cout&lt;&lt;&quot;Not found&quot;&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、字符串数组模板&quot;&gt;&lt;a href=&quot;#一、字符串数组模板&quot; class=&quot;headerlink&quot; title=&quot;一、字符串数组模板&quot;&gt;&lt;/a&gt;一、字符串数组模板&lt;/h1&gt;&lt;p&gt;思路：把句子中所有字符串取出放入字符串数组，再对数组中的字符串进行操作后重新连接即可</summary>
      
    
    
    
    
    <category term="字符串数组" scheme="http://fhc20001118.github.io/project/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>链表刷题笔记</title>
    <link href="http://fhc20001118.github.io/project/2022/11/28/%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://fhc20001118.github.io/project/2022/11/28/%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2022-11-27T16:00:00.000Z</published>
    <updated>2022-12-16T03:31:51.530Z</updated>
    
    <content type="html"><![CDATA[<p>1、当要删除头结点时，可以给链表增加一个虚拟的空头结点</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode *dummyHead &#x3D; new Listnode(0);dummyHead-&gt;next &#x3D; head;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2、用双指针找链表的相交结点时</p><p>这一段代码千万别写成pA-&gt;next == nullptr,因为这样会跳过当他们没有交点的时候，事实上不管两个链表是不是会相交，pA和pB都会相遇，但是当两个链表不相交时，他们同时为nullptr罢了，如果用 pA-&gt;next == nullptr来判断的话，会跳过他们同时等于 nullptr 的情况</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while (pA !&#x3D; pB) &#123;            pA &#x3D; pA &#x3D;&#x3D; nullptr? headB : pA-&gt;next;            pB &#x3D; pB &#x3D;&#x3D; nullptr? headA : pB-&gt;next;        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、当要删除头结点时，可以给链表增加一个虚拟的空头结点&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-c++&quot; data-language=&quot;c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;ListNode *dummyHead</summary>
      
    
    
    
    <category term="算法" scheme="http://fhc20001118.github.io/project/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="链表" scheme="http://fhc20001118.github.io/project/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
